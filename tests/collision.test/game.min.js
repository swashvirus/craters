/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./game.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../../../../../usr/lib/node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "../../../../../../usr/lib/node_modules/webpack/node_modules/process/browser.js":
/*!*************************************************!*\
  !*** (webpack)/node_modules/process/browser.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///(webpack)/node_modules/process/browser.js?");

/***/ }),

/***/ "../../../../../../usr/lib/node_modules/webpack/node_modules/setimmediate/setImmediate.js":
/*!***********************************************************!*\
  !*** (webpack)/node_modules/setimmediate/setImmediate.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6â€“8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buildin/global.js */ \"../../../../../../usr/lib/node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"../../../../../../usr/lib/node_modules/webpack/node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///(webpack)/node_modules/setimmediate/setImmediate.js?");

/***/ }),

/***/ "../../../../../../usr/lib/node_modules/webpack/node_modules/timers-browserify/main.js":
/*!********************************************************!*\
  !*** (webpack)/node_modules/timers-browserify/main.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ \"../../../../../../usr/lib/node_modules/webpack/node_modules/setimmediate/setImmediate.js\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buildin/global.js */ \"../../../../../../usr/lib/node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///(webpack)/node_modules/timers-browserify/main.js?");

/***/ }),

/***/ "../../craters/Collision/Broadphase.js":
/*!*****************************************************************************!*\
  !*** /storage/sdcard0/.htdocs/craters-beta/craters/Collision/Broadphase.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Broadphase; });\nclass Broadphase {\n    // \n    static collides(collider, collidee) {\n        if (collider.collision.collides && collidee.collision.collides) {\n            // TODO: \n            // additionally check group \n            return true;\n        }\n        return false;\n    }\n    \n    static query(collidee, quad) {\n\t    let collideds = [];\n\t    let collided = quad.retrieve(collidee);\n\t    collided.forEach((item) => {collideds.push(item.item)})\n\t    return collideds;\n    }\n}\n\n//# sourceURL=webpack:////storage/sdcard0/.htdocs/craters-beta/craters/Collision/Broadphase.js?");

/***/ }),

/***/ "../../craters/Collision/Narrowphase.js":
/*!******************************************************************************!*\
  !*** /storage/sdcard0/.htdocs/craters-beta/craters/Collision/Narrowphase.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Narrowphase; });\n/* harmony import */ var _Geometry_SAT_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Geometry/SAT.js */ \"../../craters/Geometry/SAT.js\");\n\n\nclass Narrowphase {\n    static overlap(collider, collidee) {\n        return true;\n    }\n    \n    static query(collidee, colliders) {\n\t    let collided = [];\n\t    \n\t    colliders.forEach((collider) => {\n\t\t    if(this.overlap(collider, collidee))\n\t\t    collided.push(collider)\n\t    })\n\t    \n\t    return collided;\n    }\n}\n\n//# sourceURL=webpack:////storage/sdcard0/.htdocs/craters-beta/craters/Collision/Narrowphase.js?");

/***/ }),

/***/ "../../craters/Collision/Solver.js":
/*!*************************************************************************!*\
  !*** /storage/sdcard0/.htdocs/craters-beta/craters/Collision/Solver.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Solver; });\n/* harmony import */ var _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Geometry/Geometry.js */ \"../../craters/Geometry/Geometry.js\");\n/* harmony import */ var _Fixture_Circle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Fixture/Circle.js */ \"../../craters/Fixture/Circle.js\");\n/* harmony import */ var _Fixture_Polygon_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Fixture/Polygon.js */ \"../../craters/Fixture/Polygon.js\");\n/* harmony import */ var _Geometry_SAT_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Geometry/SAT.js */ \"../../craters/Geometry/SAT.js\");\n\n\n\n\n\nclass Solver {\n\tconstructor() {\n\t\tthis.response = new _Geometry_SAT_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].Response(); // Response reused for collisions\n\t}\n\tresolve(collidee, colliders) {\n\t\tcolliders.forEach((collider) => {\n\t\t\tlet collided;\n\t\t\tif (collider.fixture instanceof _Fixture_Circle_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\n\t\t\t\tif (collidee.fixture instanceof _Fixture_Circle_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\n\t\t\t\t\tcollided = _Geometry_SAT_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].testCircleCircle(collider.fixture, collidee.fixture, this.response);\n\t\t\t\t} else {\n\t\t\t\t\tcollided = _Geometry_SAT_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].testCirclePolygon(collider.fixture, collidee.fixture, this.response);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (collidee.fixture instanceof _Fixture_Circle_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\n\t\t\t\t\tcollided = _Geometry_SAT_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].testPolygonCircle(collider.fixture, collidee.fixture, this.response);\n\t\t\t\t} else {\n\t\t\t\t\tcollided = _Geometry_SAT_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].testPolygonPolygon(collider.fixture, collidee.fixture, this.response);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (collided) {\n\t\t\t\t// TODO look into this\n\t\t\t\tif (collider.type == 'kinematic') {\n\t\t\t\t  // Move the collidee object out of us\n\t\t\t\t  collidee.state.position.add(this.response.overlapV);\n\t\t\t\t  collidee.state.velocity.add(this.response.overlapV);\n\t\t\t\t} else if (collidee.type == 'kinematic') {\n\t\t\t\t  // Move us out of the collidee object\n\t\t\t\t  collider.state.position.sub(this.response.overlapV);\n\t\t\t\t  collider.state.velocity.sub(this.response.overlapV);\n\t\t\t\t} else {\n\t\t\t\t  // Move equally out of each collidee\n\t\t\t\t  this.response.overlapV.scale(0.5);\n\t\t\t\t  collider.state.position.sub(this.response.overlapV);\n\t\t\t\t  collidee.state.position.add(this.response.overlapV);\n\t\t\t\t  \n\t\t\t\t  collider.state.velocity.sub(this.response.overlapV);\n\t\t\t\t  collidee.state.velocity.add(this.response.overlapV);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.response.clear();\n\t\t})\n\t}\n};\n\n//# sourceURL=webpack:////storage/sdcard0/.htdocs/craters-beta/craters/Collision/Solver.js?");

/***/ }),

/***/ "../../craters/Entity.js":
/*!***************************************************************!*\
  !*** /storage/sdcard0/.htdocs/craters-beta/craters/Entity.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Entity; });\n/* harmony import */ var _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Geometry/Geometry.js */ \"../../craters/Geometry/Geometry.js\");\n/* harmony import */ var _Texture_Textures_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Texture/Textures.js */ \"../../craters/Texture/Textures.js\");\n\n\n\nclass Entity {\n    constructor(params) {\n\t\t// define shortcuts \n\t\tlet vec = _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__[\"Vector\"];\n\t\tlet num = Number;\n\t\tlet obj = Object;\n\t\tlet str = String;\n\t\tlet arr = Array;\n\t\t\n\t\tparams.debug = params.debug || false;\n\t\tparams.position = params.position || new vec()\n\t\tparams.angle = params.angle || new num();\n\t\tparams.maxVelocity = params.maxVelocity || new vec(200, 200)\n\t\tparams.velocity = params.velocity || new vec()\n\t\tparams.acceleration = params.acceleration || new vec()\n\t\tparams.mass = params.mass || new num(1);\n\t\tparams.force = params.force || new vec()\n\t\tparams.texture = params.texture || new obj({\n\t\t\t// texture properties\n\t\t})\n\t\tparams.texture.style = params.texture.style || new obj({\n\t\t\t// texture style properties\n\t\t})\n\t\tparams.texture.style.fillStyle = params.texture.style.fillStyle || new str(\"#ddd\")\n\t\tparams.texture.style.lineWidth = params.texture.style.lineWidth || new num(2)\n\t\tparams.texture.style.strokeStyle = params.texture.style.strokeStyle || new str(\"#333\")\n\t\t\n\t\tthis.debug = params.debug;\n\t\tthis.state = {\n\t\t\t// an object storing\n\t\t\t// entity properties\n\t\t}\n\t\tthis.state.position = params.position\n\t\tthis.state.angle = params.angle\n\t\t\n\t\tparams.collision = params.collision || new obj({\n\t\t\t// collision properties\n\t\t})\n\t\t// default collision properties\n\t\tparams.collision.collides = params.collision.collides || true;\n\t\tparams.collision.group = params.collision.group || new arr(['everyone']);\n\t\tparams.collision.checkAgenist = params.collision.checkAgenist || new arr(['everyone']);\n\t\tparams.gravityFactor = params.gravityFactor || new vec(1, 1)\n\t\t\n\t\t// collision properties\n\t\tthis.collision = {\n\t\t\tcollides: params.collision.collides,\n\t\t\tgroup: params.collision.group,\n\t\t\tcheckAgenist: params.collision.checkAgenist\n\t\t}\n\t\t\n\t\t// body dynamics\n\t\tthis.state.force = params.force\n\t\tthis.gravityFactor = params.gravityFactor\n\t\t// mass\n\t\tthis.state.mass = params.mass\n        // body kinematics\n        this.state.maxVelocity = params.maxVelocity\n        this.state.velocity = params.velocity\n        this.state.acceleration = params.acceleration\n        \n        // body type\n        this.types = {\n\t        kinematic: 'kinematic',\n\t        dynamic: 'dynamic'\n        }\n        \n        // set default body type\n        this.type = params.type;\n        \n        // fixture\n        this.fixture = {\n\t        // friction\n\t        // size\n\t        // density\n\t        // material\n        }\n        \n        // body texture\n        this.texture = new _Texture_Textures_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Sprite(this, params.texture);\n    }\n    \n    // update own state\n    update () {\n    \n    }\n    \n    // render own state\n    render() {\n\t    let style = this.texture.style;\n\t    let context = this.context;\n\t    \n\t    if(this.debug) {\n\t    // Todo more tools , centroid.\n\t    context.save()\n\t    context.beginPath();\n\t    context.strokeStyle = \"red\";\n\t    context.lineWidth = \"1\";\n\t    \n\t    let bounds = this.fixture.getAABB();\n\t    let edges = bounds.edges;\n\t    let width = (edges[0].x - edges[2].x) / 2,\n\t\t    height = (edges[1].y - edges[3].y) / 2;\n\t    let position = this.state.position;\n\t    let x = position.x,\n\t\t    y = position.y;\n\t    if(this.fixture.type == \"circle\")\n\t    x = position.x - (width / 2),\n\t\ty = position.y - (height / 2);\n\t    \n\t    context.rect(x , y , width, height)\n\t    context.stroke()\n\t    context.restore()\n\t    }\n\t    context.fillStyle = style.fillStyle;\n\t    context.lineWidth =  style.lineWidth;\n\t    context.strokeStyle = style.strokeStyle;\n\t    context.lineJoin = 'miter';\n    }\n}\n\n//# sourceURL=webpack:////storage/sdcard0/.htdocs/craters-beta/craters/Entity.js?");

/***/ }),

/***/ "../../craters/Fixture/Circle.js":
/*!***********************************************************************!*\
  !*** /storage/sdcard0/.htdocs/craters-beta/craters/Fixture/Circle.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Circle; });\n/* harmony import */ var _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Geometry/Geometry.js */ \"../../craters/Geometry/Geometry.js\");\n/* harmony import */ var _Geometry_AABB_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Geometry/AABB.js */ \"../../craters/Geometry/AABB.js\");\n// ## Circle\n// Represents a circular fixture\n\n\n\nclass Circle {\n\tconstructor(pos, r) {\n\t\tthis['type'] = 'circle'\n\t\tthis['pos'] = pos || new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__[\"Vector\"]();\n\t\tthis['r'] = r || 0;\n\t\tthis['offset'] = new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__[\"Vector\"]();\n\t}\n\t\n\t// Compute the axis-aligned bounding AABB (AABB) of this Circle.\n\t//\n\t// Note: Returns a _new_ `Polygon` each time you call this.\n\t/**\n\t* @return {Polygon} The AABB\n\t*/\n\tgetAABB() {\n\t\tvar r = this['r'];\n\t\tvar corner = this['pos'].clone().add(this['offset']).sub(new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__[\"Vector\"](r, r));\n\t\treturn new _Geometry_AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](corner, r*2, r*2).toPolygon();\n\t};\n\tgetCentroid() {\n\t\tlet aabb = this.getAABB();\n\t\tlet x = aabb.edges[3].x;\n\t\tlet y = aabb.edges[2].y;\n\t\tlet cx = (aabb.edges[0].x - x) / 2;\n\t\tlet cy = (aabb.edges[1].y - y) / 2;\n\t\treturn new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__[\"Vector\"](cx, cy);\n\t}\n\t// Set the current offset to apply to the radius.\n\t/**\n\t* @param {Vector} offset The new offset vector.\n\t* @return {Circle} This for chaining.\n\t*/\n\tsetOffset(offset) {\n\t\tthis['offset'] = offset;\n\t\treturn this;\n\t}\n}\n\n//# sourceURL=webpack:////storage/sdcard0/.htdocs/craters-beta/craters/Fixture/Circle.js?");

/***/ }),

/***/ "../../craters/Fixture/Fixtures.js":
/*!*************************************************************************!*\
  !*** /storage/sdcard0/.htdocs/craters-beta/craters/Fixture/Fixtures.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Fixture_Circle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Fixture/Circle.js */ \"../../craters/Fixture/Circle.js\");\n/* harmony import */ var _Fixture_Polygon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Fixture/Polygon.js */ \"../../craters/Fixture/Polygon.js\");\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({Circle: _Fixture_Circle_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"], Polygon: _Fixture_Polygon_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]});\n\n//# sourceURL=webpack:////storage/sdcard0/.htdocs/craters-beta/craters/Fixture/Fixtures.js?");

/***/ }),

/***/ "../../craters/Fixture/Polygon.js":
/*!************************************************************************!*\
  !*** /storage/sdcard0/.htdocs/craters-beta/craters/Fixture/Polygon.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Polygon; });\n/* harmony import */ var _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Geometry/Geometry.js */ \"../../craters/Geometry/Geometry.js\");\n/* harmony import */ var _Geometry_AABB_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Geometry/AABB.js */ \"../../craters/Geometry/AABB.js\");\n// ## Polygon\n// Represents a *convex* polygon with any number of points (specified in counter-clockwise order)\n\n\n\nclass Polygon {\n\tconstructor(pos, points) {\n\t\tthis['type'] = 'polygon'\n\t\tthis['pos'] = pos || new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__[\"Vector\"]();\n\t\tthis['angle'] = 0;\n\t\tthis['offset'] = new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__[\"Vector\"]();\n\t\tthis.setPoints(points || []);\n\t}\n\tsetPoints(points) {\n\t\t// Only re-allocate if this is a new polygon or the number of points has changed.\n\t\tvar lengthChanged = !this['points'] || this['points'].length !== points.length;\n\t\tif (lengthChanged) {\n\t\t\tvar i;\n\t\t\tvar calcPoints = this['calcPoints'] = [];\n\t\t\tvar edges = this['edges'] = [];\n\t\t\tvar normals = this['normals'] = [];\n\t\t\t// Allocate the vector arrays for the calculated properties\n\t\t\tfor (i = 0; i < points.length; i++) {\n\t\t\t// Remove consecutive duplicate points\n\t\t\tvar p1 = points[i];\n\t\t\tvar p2 = i < points.length - 1 ? points[i + 1] : points[0];\n\t\t\tif (p1 !== p2 && p1.x === p2.x && p1.y === p2.y) {\n\t\t\tpoints.splice(i, 1);\n\t\t\ti -= 1;\n\t\t\tcontinue;\n\t\t\t}\n\t\t\tcalcPoints.push(new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__[\"Vector\"]());\n\t\t\tedges.push(new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__[\"Vector\"]());\n\t\t\tnormals.push(new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__[\"Vector\"]());\n\t\t\t}\n\t\t}\n\t\tthis['points'] = points;\n\t\tthis._recalc();\n\t\treturn this;\n\t};\n\tsetAngle(angle) {\n\t\tthis['angle'] = angle;\n\t\tthis._recalc();\n\t\treturn this;\n\t};\n\tsetOffset(offset) {\n\t\tthis['offset'] = offset;\n\t\tthis._recalc();\n\t\treturn this;\n\t};\n\t\n\trotate(angle) {\n\t\tvar points = this['points'];\n\t\tvar len = points.length;\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tpoints[i].rotate(angle);\n\t\t}\n\t\tthis._recalc();\n\t\treturn this;\n\t};\n\ttranslate(x, y) {\n\t\tvar points = this['points'];\n\t\tvar len = points.length;\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tpoints[i][\"x\"] += x;\n\t\t\tpoints[i][\"y\"] += y;\n\t\t}\n\t\tthis._recalc();\n\t\treturn this;\n\t};\n\t\n\t_recalc() {\n\t\tvar calcPoints = this['calcPoints'];\n\t\tvar edges = this['edges'];\n\t\tvar normals = this['normals'];\n\t\t// Copy the original points array and apply the offset/angle\n\t\tvar points = this['points'];\n\t\tvar offset = this['offset'];\n\t\tvar angle = this['angle'];\n\t\tvar len = points.length;\n\t\tvar i;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tvar calcPoint = calcPoints[i].copy(points[i]);\n\t\t\tcalcPoint[\"x\"] += offset[\"x\"];\n\t\t\tcalcPoint[\"y\"] += offset[\"y\"];\n\t\t\tif (angle !== 0) {\n\t\t\t\tcalcPoint.rotate(angle);\n\t\t\t}\n\t\t}\n\t\t// Calculate the edges/normals\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tvar p1 = calcPoints[i];\n\t\t\tvar p2 = i < len - 1 ? calcPoints[i + 1] : calcPoints[0];\n\t\t\tvar e = edges[i].copy(p2).sub(p1);\n\t\t\tnormals[i].copy(e).perp().normalize();\n\t\t}\n\t\treturn this;\n\t};\n\t\n\tgetAABB() {\n\t\tvar points = this[\"calcPoints\"];\n\t\tvar len = points.length;\n\t\tvar xMin = points[0][\"x\"];\n\t\tvar yMin = points[0][\"y\"];\n\t\tvar xMax = points[0][\"x\"];\n\t\tvar yMax = points[0][\"y\"];\n\t\tfor (var i = 1; i < len; i++) {\n\t\t\tvar point = points[i];\n\t\t\tif (point[\"x\"] < xMin) {\n\t\t\t\txMin = point[\"x\"];\n\t\t\t}\n\t\t\telse if (point[\"x\"] > xMax) {\n\t\t\t\txMax = point[\"x\"];\n\t\t\t}\n\t\t\tif (point[\"y\"] < yMin) {\n\t\t\t\tyMin = point[\"y\"];\n\t\t\t}\n\t\t\telse if (point[\"y\"] > yMax) {\n\t\t\t\tyMax = point[\"y\"];\n\t\t\t}\n\t\t}\n\t\treturn new _Geometry_AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this['pos'].clone().add(new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__[\"Vector\"](xMin, yMin)), xMax - xMin, yMax - yMin).toPolygon();\n\t};\n\t\n\tgetCentroid() {\n\t\tvar points = this[\"calcPoints\"];\n\t\tvar len = points.length;\n\t\tvar cx = 0;\n\t\tvar cy = 0;\n\t\tvar ar = 0;\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tvar p1 = points[i];\n\t\t\tvar p2 = i === len - 1 ? points[0] : points[i+1]; // Loop around if last point\n\t\t\tvar a = p1[\"x\"] * p2[\"y\"] - p2[\"x\"] * p1[\"y\"];\n\t\t\tcx += (p1[\"x\"] + p2[\"x\"]) * a;\n\t\t\tcy += (p1[\"y\"] + p2[\"y\"]) * a;\n\t\t\tar += a;\n\t\t}\n\t\tar = ar * 3; // we want 1 / 6 the area and we currently have 2*area\n\t\tcx = cx / ar;\n\t\tcy = cy / ar;\n\t\treturn new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__[\"Vector\"](cx, cy);\n\t}\n}\n\n//# sourceURL=webpack:////storage/sdcard0/.htdocs/craters-beta/craters/Fixture/Polygon.js?");

/***/ }),

/***/ "../../craters/Game.js":
/*!*************************************************************!*\
  !*** /storage/sdcard0/.htdocs/craters-beta/craters/Game.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Game; });\n/* harmony import */ var _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Geometry/Geometry.js */ \"../../craters/Geometry/Geometry.js\");\n/* harmony import */ var _System_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./System.js */ \"../../craters/System.js\");\n/* harmony import */ var _Modules_Tilemap_Tilemap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Modules/Tilemap/Tilemap.js */ \"../../craters/Modules/Tilemap/Tilemap.js\");\n/* harmony import */ var _Collision_Broadphase_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Collision/Broadphase.js */ \"../../craters/Collision/Broadphase.js\");\n/* harmony import */ var _Collision_Narrowphase_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Collision/Narrowphase.js */ \"../../craters/Collision/Narrowphase.js\");\n/* harmony import */ var _Collision_Solver_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Collision/Solver.js */ \"../../craters/Collision/Solver.js\");\n/* harmony import */ var _Fixture_Circle_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Fixture/Circle.js */ \"../../craters/Fixture/Circle.js\");\n/* harmony import */ var _Fixture_Polygon_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Fixture/Polygon.js */ \"../../craters/Fixture/Polygon.js\");\n\n\n\n\n\n\n\n\n\n\n\nclass Game {\n\tconstructor(params) {\n\t\tparams.entities = params.entities || [];\n\t\tparams.size = params.size || new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__[\"Vector\"](1000, 500);\n\t\tparams.gravity = params.gravity || new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__[\"Vector\"]();\n\t\tparams.quad = params.quad || new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__[\"Vector\"]();\n\t\tparams.resources = params.resources || {\n\t\t\t// resources object\n\t\t};\n\t\tparams.resources.image = params.resources.image || [];\n\t\tparams.resources.audio = params.resources.audio || [];\n\t\tparams.resources.data = params.resources.data  || [];\n\t\t\n\t\tparams.fps = params.fps || 60;\n\t\tparams.debug = params.debug || false;\n\t\t\n\t\tthis.entities = params.entities;\n\t\tthis.debug = params.debug;\n\t\tthis.state = {\n\t\t\tsize: params.size,\n\t\t\tgravity: params.gravity\n\t\t}\n\t\n\t\t// create viewport\n\t\tthis.viewport = new _System_js__WEBPACK_IMPORTED_MODULE_1__[\"Canvas\"](this.state.size.x, this.state.size.y, params.container);\n\t\tthis.context = this.viewport.context;\n\t\t// Create new grid\n\t\tthis.quad = new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__[\"QuadTree\"]({x: params.quad.x, y: params.quad.y, width: params.size.x, height: params.size.y});\n\t\tthis.solver = new _Collision_Solver_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]();\n\t\tthis.tilemap = new _Modules_Tilemap_Tilemap_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](params.tilemap, this.context, this.quad)\n\t\t\n\t\t// Loop main game\n\t\tthis.loop = new _System_js__WEBPACK_IMPORTED_MODULE_1__[\"Loop\"](this, params.fps)\n\t\twindow['cg'] = this;\n\t}\n\t\n\taddObject(object) {\n\t\t// used for adding entities\n\t\tobject.context = this.context;\n\t\treturn this.entities.push(object)\n\t}\n\t\n\tremoveObject(index) {\n\t\t// used to remove entities\n\t\t// this.quad.remove(this.entities[index])\n\t\treturn this.entities.splice(index, 1)\n\t}\n\t\n\tupdate() {\n\t\tthis.quad.clear()\n\t\tthis.tilemap.update()\n\t\t// Loop through all bodies and update one at a time\n\t\tthis.entities.forEach((body) => {\n\t\t\t// update grid quad\n\t\t\tlet item = body;\n\t\t\tlet bounds = item.fixture.getAABB();\n\t\t\tlet edges = bounds.edges;\n\t\t\tlet width = (edges[0].x - edges[2].x) / 2,\n\t\t\t\theight = (edges[1].y - edges[3].y) / 2;\n\t\t\tlet position = item.state.position;\n\t\t\tlet x = position.x,\n\t\t\t\ty = position.y;\n\t\t\tif(item.fixture.type == \"circle\")\n\t\t\tx = position.x - (width / 2),\n\t\t\ty = position.y - (height / 2);\n\t\t\tthis.quad.insert({x , y , width, height, item})\n\t\t\t\n\t\t\tlet broad = _Collision_Broadphase_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].query(body, this.quad)\n\t\t\tlet narrow = _Collision_Narrowphase_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].query(body, broad)\n\t\t\tthis.solver.resolve(body, narrow);\n\t\t\t// kinematics\n\t\t\tlet gravity = this.state.gravity.clone().scale(body.gravityFactor.x, body.gravityFactor.y);\n\t\t\tlet mass = body.state.mass;\n\t\t\t\n\t\t\tbody.state.acceleration.add(gravity);\n\t\t\tbody.state.velocity.add(body.state.acceleration);\n\t\t\t\n\t\t\tbody.state.velocity.x = Math.min(body.state.velocity.x, body.state.maxVelocity.x);\n\t\t\tbody.state.velocity.y = Math.min(body.state.velocity.y, body.state.maxVelocity.y);\n\t\t\t\n\t\t\tbody.state.position.add(body.state.velocity.clone().scale(1 / this.state.loop.nframe))\n\t\t\tbody.update();\n\t\t})\n\t}\n\t\n\trender() {\n\t\t// background clear\n\t\tthis.viewport.clear()\n\t\tthis.tilemap.render()\n\t\t\n\t\tif(this.debug) {\n\t\t\tlet node = this.quad.root;\n\t\t\tlet drawBound = (node) => {\n\t\t\t\tlet bounds = node._bounds;\n\t\t\t\tlet abs = _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__[\"Maths\"].abs;\n\t\t\t\tlet context = this.context;\n\t\t\t\t\n\t\t\t\tcontext.save()\n\t\t\t\tcontext.strokeStyle = \"green\";\n\t\t\t\tcontext.lineWidth = \"2\";\n\t\t\t\tcontext.beginPath();\n\t\t\t\tcontext.rect(bounds.x, bounds.y, bounds.width, bounds.height);\n\t\t\t\t\n\t\t\t\tlet children = node.getChildren();\n\t\t\t\tlet childlength = children.length;\n\t\t\t\tlet childNode;\n\t\t\t\tif(childlength) {\n\t\t\t\t\tfor(let j = 0; j < childlength; j++) {\n\t\t\t\t\tchildNode = children[j];\n\t\t\t\t\tcontext.beginPath();\n\t\t\t\t\tcontext.rect(childNode.x, childNode.y, childNode.width, childNode.height);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tlet len = node.nodes.length;\n\t\t\t\tfor(let i = 0; i < len; i++) {\n\t\t\t\t\tdrawBound(node.nodes[i]);\n\t\t\t\t}\n\t\t\t\tcontext.stroke()\n\t\t\t\tcontext.restore();\n\t\t\t}\n\t\t\t// draw the QuadTree grid\n\t\t\tdrawBound(node);\n\t\t}\n\t\t\n\t\tthis.entities.forEach((body) => {\n\t\t\t// render body\n\t\t\tbody.render();\n\t\t\tbody.texture.update();\n\t\t\tbody.texture.render();\n\t\t})\n\t}\n}\n\n//# sourceURL=webpack:////storage/sdcard0/.htdocs/craters-beta/craters/Game.js?");

/***/ }),

/***/ "../../craters/Geometry/AABB.js":
/*!**********************************************************************!*\
  !*** /storage/sdcard0/.htdocs/craters-beta/craters/Geometry/AABB.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return AABB; });\n/* harmony import */ var _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Geometry/Geometry.js */ \"../../craters/Geometry/Geometry.js\");\n/* harmony import */ var _Fixture_Polygon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Fixture/Polygon.js */ \"../../craters/Fixture/Polygon.js\");\n// ## AABB\n// Represents an axis-aligned AABB, with a width and height.\n\n\n\nclass AABB {\n\tconstructor(pos, w, h) {\n\t\tthis['pos'] = pos || new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__[\"Vector\"]();\n\t\tthis['w'] = w || 0;\n\t\tthis['h'] = h || 0;\n\t}\n\t\n\t// Returns a polygon whose edges are the same as this AABB.\n\ttoPolygon() {\n\t\tvar pos = this['pos'];\n\t\tvar w = this['w'];\n\t\tvar h = this['h'];\n\t\treturn new _Fixture_Polygon_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__[\"Vector\"](pos['x'], pos['y']), [\n\t\t\tnew _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__[\"Vector\"](), new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__[\"Vector\"](w, 0),\n\t\t\tnew _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__[\"Vector\"](w,h), new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__[\"Vector\"](0,h)\n\t\t]);\n\t}\n}\n\n//# sourceURL=webpack:////storage/sdcard0/.htdocs/craters-beta/craters/Geometry/AABB.js?");

/***/ }),

/***/ "../../craters/Geometry/Common.js":
/*!************************************************************************!*\
  !*** /storage/sdcard0/.htdocs/craters-beta/craters/Geometry/Common.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nconst degToRad = function(angle) {\n    return angle * Math.PI / 180;\n};\n\nconst radToDeg = function(angle) {\n    return angle * 180 / Math.PI;\n};\n\nconst distance = function(x1, y1, x2, y2) {\n    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n};\n\nconst map = function(value, low1, high1, low2, high2) {\n    return low2 + (high2 - low2) * (value - low1) / (high1 - low1);\n};\n\nconst boundary = function(value, min, max) {\n    return Math.min(Math.max(value, min), max)\n};\n\nconst abs = function abs(x) {\n\treturn (x < 0 ? -x : x)\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({abs, boundary, degToRad, radToDeg, distance, map});\n\n//# sourceURL=webpack:////storage/sdcard0/.htdocs/craters-beta/craters/Geometry/Common.js?");

/***/ }),

/***/ "../../craters/Geometry/Geometry.js":
/*!**************************************************************************!*\
  !*** /storage/sdcard0/.htdocs/craters-beta/craters/Geometry/Geometry.js ***!
  \**************************************************************************/
/*! exports provided: Maths, Vector, QuadTree */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Common.js */ \"../../craters/Geometry/Common.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Maths\", function() { return _Common_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n/* harmony import */ var _QuadTree_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./QuadTree.js */ \"../../craters/Geometry/QuadTree.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"QuadTree\", function() { return _QuadTree_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; });\n\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Vector.js */ \"../../craters/Geometry/Vector.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Vector\", function() { return _Vector_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; });\n\n// load the methods and sub divided them\n// to make bite sized methods\n// vectors, fixtures, common\n\n\n\n\n\n\n//# sourceURL=webpack:////storage/sdcard0/.htdocs/craters-beta/craters/Geometry/Geometry.js?");

/***/ }),

/***/ "../../craters/Geometry/QuadTree.js":
/*!**************************************************************************!*\
  !*** /storage/sdcard0/.htdocs/craters-beta/craters/Geometry/QuadTree.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return QuadTree; });\n/*jslint vars: true, nomen: true, plusplus: true, continue:true, forin:true */\n/*global Node, BoundsNode */\n\n/*\n\tThe MIT License\n\n\tCopyright (c) 2011 Mike Chambers\n\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\n\tThe above copyright notice and this permission notice shall be included in\n\tall copies or substantial portions of the Software.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\tTHE SOFTWARE.\n*/\n\n\n/**\n* A QuadTree implementation in JavaScript, a 2d spatial subdivision algorithm.\n* @module QuadTree\n**/\n\n    /****************** QuadTree ****************/\n\n    /**\n    * QuadTree data structure.\n    * @class QuadTree\n    * @constructor\n    * @param {Object} An object representing the bounds of the top level of the QuadTree. The object \n    * should contain the following properties : x, y, width, height\n    * @param {Boolean} pointQuad Whether the QuadTree will contain points (true), or items with bounds \n    * (width / height)(false). Default value is false.\n    * @param {Number} maxDepth The maximum number of levels that the quadtree will create. Default is 4.\n    * @param {Number} maxChildren The maximum number of children that a node can contain before it is split into sub-nodes.\n    **/\n    function QuadTree(bounds, pointQuad, maxDepth, maxChildren) {\n        var node;\n        if (pointQuad) {\n\n            node = new Node(bounds, 0, maxDepth, maxChildren);\n        } else {\n            node = new BoundsNode(bounds, 0, maxDepth, maxChildren);\n        }\n\n        this.root = node;\n    }\n\n    /**\n    * The root node of the QuadTree which covers the entire area being segmented.\n    * @property root\n    * @type Node\n    **/\n    QuadTree.prototype.root = null;\n\n\n    /**\n    * Inserts an item into the QuadTree.\n    * @method insert\n    * @param {Object|Array} item The item or Array of items to be inserted into the QuadTree. The item should expose x, y \n    * properties that represents its position in 2D space.\n    **/\n    QuadTree.prototype.insert = function (item) {\n        if (item instanceof Array) {\n            var len = item.length;\n\n            var i;\n            for (i = 0; i < len; i++) {\n                this.root.insert(item[i]);\n            }\n        } else {\n            this.root.insert(item);\n        }\n    };\n\n    /**\n    * Clears all nodes and children from the QuadTree\n    * @method clear\n    **/\n    QuadTree.prototype.clear = function () {\n        this.root.clear();\n    };\n\n    /**\n    * Retrieves all items / points in the same node as the specified item / point. If the specified item\n    * overlaps the bounds of a node, then all children in both nodes will be returned.\n    * @method retrieve\n    * @param {Object} item An object representing a 2D coordinate point (with x, y properties), or a shape\n    * with dimensions (x, y, width, height) properties.\n    **/\n    QuadTree.prototype.retrieve = function (item) {\n        //get a copy of the array of items\n        var out = this.root.retrieve(item).slice(0);\n        return out;\n    };\n\n    /************** Node ********************/\n\n\n    function Node(bounds, depth, maxDepth, maxChildren) {\n        this._bounds = bounds;\n        this.children = [];\n        this.nodes = [];\n\n        if (maxChildren) {\n            this._maxChildren = maxChildren;\n        }\n\n        if (maxDepth) {\n            this._maxDepth = maxDepth;\n        }\n\n        if (depth) {\n            this._depth = depth;\n        }\n    }\n\n    //subnodes\n    Node.prototype.nodes = null;\n    Node.prototype._classConstructor = Node;\n\n    //children contained directly in the node\n    Node.prototype.children = null;\n    Node.prototype._bounds = null;\n\n    //read only\n    Node.prototype._depth = 0;\n\n    Node.prototype._maxChildren = 4;\n    Node.prototype._maxDepth = 4;\n\n    Node.TOP_LEFT = 0;\n    Node.TOP_RIGHT = 1;\n    Node.BOTTOM_LEFT = 2;\n    Node.BOTTOM_RIGHT = 3;\n\n\n    Node.prototype.insert = function (item) {\n        if (this.nodes.length) {\n            var index = this._findIndex(item);\n\n            this.nodes[index].insert(item);\n\n            return;\n        }\n\n        this.children.push(item);\n\n        var len = this.children.length;\n        if (!(this._depth >= this._maxDepth) &&\n                len > this._maxChildren) {\n            \n            this.subdivide();\n\n            var i;\n            for (i = 0; i < len; i++) {\n                this.insert(this.children[i]);\n            }\n\n            this.children.length = 0;\n        }\n    };\n\n    Node.prototype.retrieve = function (item) {\n        if (this.nodes.length) {\n            var index = this._findIndex(item);\n\n            return this.nodes[index].retrieve(item);\n        }\n\n        return this.children;\n    };\n\n    Node.prototype._findIndex = function (item) {\n        var b = this._bounds;\n        var left = (item.x > b.x + b.width / 2) ? false : true;\n        var top = (item.y > b.y + b.height / 2) ? false : true;\n\n        //top left\n        var index = Node.TOP_LEFT;\n        if (left) {\n            //left side\n            if (!top) {\n                //bottom left\n                index = Node.BOTTOM_LEFT;\n            }\n        } else {\n            //right side\n            if (top) {\n                //top right\n                index = Node.TOP_RIGHT;\n            } else {\n                //bottom right\n                index = Node.BOTTOM_RIGHT;\n            }\n        }\n\n        return index;\n    };\n\n\n    Node.prototype.subdivide = function () {\n        var depth = this._depth + 1;\n\n        var bx = this._bounds.x;\n        var by = this._bounds.y;\n\n        //floor the values\n        var b_w_h = (this._bounds.width / 2); //todo: Math.floor?\n        var b_h_h = (this._bounds.height / 2);\n        var bx_b_w_h = bx + b_w_h;\n        var by_b_h_h = by + b_h_h;\n\n        //top left\n        this.nodes[Node.TOP_LEFT] = new this._classConstructor({\n            x: bx,\n            y: by,\n            width: b_w_h,\n            height: b_h_h\n        },\n            depth, this._maxDepth, this._maxChildren);\n\n        //top right\n        this.nodes[Node.TOP_RIGHT] = new this._classConstructor({\n            x: bx_b_w_h,\n            y: by,\n            width: b_w_h,\n            height: b_h_h\n        },\n            depth, this._maxDepth, this._maxChildren);\n\n        //bottom left\n        this.nodes[Node.BOTTOM_LEFT] = new this._classConstructor({\n            x: bx,\n            y: by_b_h_h,\n            width: b_w_h,\n            height: b_h_h\n        },\n            depth, this._maxDepth, this._maxChildren);\n\n\n        //bottom right\n        this.nodes[Node.BOTTOM_RIGHT] = new this._classConstructor({\n            x: bx_b_w_h,\n            y: by_b_h_h,\n            width: b_w_h,\n            height: b_h_h\n        },\n            depth, this._maxDepth, this._maxChildren);\n    };\n\n    Node.prototype.clear = function () {\n        this.children.length = 0;\n\n        var len = this.nodes.length;\n        \n        var i;\n        for (i = 0; i < len; i++) {\n            this.nodes[i].clear();\n        }\n\n        this.nodes.length = 0;\n    };\n    \n\n    /******************** BoundsQuadTree ****************/\n\n    function BoundsNode(bounds, depth, maxChildren, maxDepth) {\n        Node.call(this, bounds, depth, maxChildren, maxDepth);\n        this._stuckChildren = [];\n    }\n\n    BoundsNode.prototype = new Node();\n    BoundsNode.prototype._classConstructor = BoundsNode;\n    BoundsNode.prototype._stuckChildren = null;\n\n    //we use this to collect and conctenate items being retrieved. This way\n    //we dont have to continuously create new Array instances.\n    //Note, when returned from QuadTree.retrieve, we then copy the array\n    BoundsNode.prototype._out = [];\n\n    BoundsNode.prototype.insert = function (item) {\n        if (this.nodes.length) {\n            var index = this._findIndex(item);\n            var node = this.nodes[index];\n\n            //todo: make _bounds bounds\n            if (item.x >= node._bounds.x &&\n                    item.x + item.width <= node._bounds.x + node._bounds.width &&\n                    item.y >= node._bounds.y &&\n                    item.y + item.height <= node._bounds.y + node._bounds.height) {\n                \n                this.nodes[index].insert(item);\n                \n            } else {\n                this._stuckChildren.push(item);\n            }\n\n            return;\n        }\n\n        this.children.push(item);\n\n        var len = this.children.length;\n\n        if (!(this._depth >= this._maxDepth) &&\n                len > this._maxChildren) {\n            \n            this.subdivide();\n\n            var i;\n            for (i = 0; i < len; i++) {\n                this.insert(this.children[i]);\n            }\n\n            this.children.length = 0;\n        }\n    };\n\n    BoundsNode.prototype.getChildren = function () {\n        return this.children.concat(this._stuckChildren);\n    };\n\n    BoundsNode.prototype.retrieve = function (item) {\n        var out = this._out;\n        out.length = 0;\n        if (this.nodes.length) {\n            var index = this._findIndex(item);\n            var node = this.nodes[index];\n\n            if (item.x >= node._bounds.x &&\n                    item.x + item.width <= node._bounds.x + node._bounds.width &&\n                    item.y >= node._bounds.y &&\n                    item.y + item.height <= node._bounds.y + node._bounds.height) {\n                \n                out.push.apply(out, this.nodes[index].retrieve(item));\n            } else {\n                //Part of the item are overlapping multiple child nodes. For each of the overlapping nodes, return all containing objects.\n\n                if (item.x <= this.nodes[Node.TOP_RIGHT]._bounds.x) {\n                    if (item.y <= this.nodes[Node.BOTTOM_LEFT]._bounds.y) {\n                        out.push.apply(out, this.nodes[Node.TOP_LEFT].getAllContent());\n                    }\n                    \n                    if (item.y + item.height > this.nodes[Node.BOTTOM_LEFT]._bounds.y) {\n                        out.push.apply(out, this.nodes[Node.BOTTOM_LEFT].getAllContent());\n                    }\n                }\n                \n                if (item.x + item.width > this.nodes[Node.TOP_RIGHT]._bounds.x) {//position+width bigger than middle x\n                    if (item.y <= this.nodes[Node.BOTTOM_RIGHT]._bounds.y) {\n                        out.push.apply(out, this.nodes[Node.TOP_RIGHT].getAllContent());\n                    }\n                    \n                    if (item.y + item.height > this.nodes[Node.BOTTOM_RIGHT]._bounds.y) {\n                        out.push.apply(out, this.nodes[Node.BOTTOM_RIGHT].getAllContent());\n                    }\n                }\n            }\n        }\n\n        out.push.apply(out, this._stuckChildren);\n        out.push.apply(out, this.children);\n\n        return out;\n    };\n\n    //Returns all contents of node.\n    BoundsNode.prototype.getAllContent = function () {\n        var out = this._out;\n        if (this.nodes.length) {\n            \n            var i;\n            for (i = 0; i < this.nodes.length; i++) {\n                this.nodes[i].getAllContent();\n            }\n        }\n        out.push.apply(out, this._stuckChildren);\n        out.push.apply(out, this.children);\n        return out;\n    };\n\n    BoundsNode.prototype.clear = function () {\n\n        this._stuckChildren.length = 0;\n\n        //array\n        this.children.length = 0;\n\n        var len = this.nodes.length;\n\n        if (!len) {\n            return;\n        }\n\n        var i;\n        for (i = 0; i < len; i++) {\n            this.nodes[i].clear();\n        }\n\n        //array\n        this.nodes.length = 0;\n\n        //we could call the super clear function but for now, im just going to inline it\n        //call the hidden super.clear, and make sure its called with this = this instance\n        //Object.getPrototypeOf(BoundsNode.prototype).clear.call(this);\n    };\n\n//# sourceURL=webpack:////storage/sdcard0/.htdocs/craters-beta/craters/Geometry/QuadTree.js?");

/***/ }),

/***/ "../../craters/Geometry/SAT.js":
/*!*********************************************************************!*\
  !*** /storage/sdcard0/.htdocs/craters-beta/craters/Geometry/SAT.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector.js */ \"../../craters/Geometry/Vector.js\");\n/* harmony import */ var _AABB_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AABB.js */ \"../../craters/Geometry/AABB.js\");\n/* harmony import */ var _Fixture_Circle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Fixture/Circle.js */ \"../../craters/Fixture/Circle.js\");\n/* harmony import */ var _Fixture_Polygon_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Fixture/Polygon.js */ \"../../craters/Fixture/Polygon.js\");\n// Version 0.8.0 - Copyright 2012 - 2018 -  Jim Riecken <jimr@jimr.ca>\n//\n// Released under the MIT License - https://github.com/jriecken/sat-js\n//\n// A simple library for determining intersections of circles and\n// polygons using the Separating Axis Theorem.\n\n\n\n\n\n  var SAT = {AABB: _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"], Circle: _Fixture_Circle_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"], Polygon: _Fixture_Polygon_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]};\n  // ## Response\n  //\n  // An object representing the result of an intersection. Contains:\n  //  - The two objects participating in the intersection\n  //  - The vector representing the minimum change necessary to extract the first object\n  //    from the second one (as well as a unit vector in that direction and the magnitude\n  //    of the overlap)\n  //  - Whether the first object is entirely inside the second, and vice versa.\n  /**\n   * @constructor\n   */\n  function Response() {\n    this['a'] = null;\n    this['b'] = null;\n    this['overlapN'] = new _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    this['overlapV'] = new _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    this.clear();\n  }\n  SAT['Response'] = Response;\n\n  // Set some values of the response back to their defaults.  Call this between tests if\n  // you are going to reuse a single Response object for multiple intersection tests (recommented\n  // as it will avoid allcating extra memory)\n  /**\n   * @return {Response} This for chaining\n   */\n  Response.prototype['clear'] = Response.prototype.clear = function() {\n    this['aInB'] = true;\n    this['bInA'] = true;\n    this['overlap'] = Number.MAX_VALUE;\n    return this;\n  };\n\n  // ## Object Pools\n\n  // A pool of `Vector` objects that are used in calculations to avoid\n  // allocating memory.\n  /**\n   * @type {Array<Vector>}\n   */\n  var T_VECTORS = [];\n  for (var i = 0; i < 10; i++) { T_VECTORS.push(new _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]()); }\n\n  // A pool of arrays of numbers used in calculations to avoid allocating\n  // memory.\n  /**\n   * @type {Array<Array<number>>}\n   */\n  var T_ARRAYS = [];\n  for (var i = 0; i < 5; i++) { T_ARRAYS.push([]); }\n\n  // Temporary response used for polygon hit detection.\n  /**\n   * @type {Response}\n   */\n  var T_RESPONSE = new Response();\n\n  // Tiny \"point\" polygon used for polygon hit detection.\n  /**\n   * @type {Polygon}\n   */\n  var TEST_POINT = new _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](new _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](), 0.000001, 0.000001).toPolygon();\n\n  // ## Helper Functions\n\n  // Flattens the specified array of points onto a unit vector axis,\n  // resulting in a one dimensional range of the minimum and\n  // maximum value on that axis.\n  /**\n   * @param {Array<Vector>} points The points to flatten.\n   * @param {Vector} normal The unit vector axis to flatten on.\n   * @param {Array<number>} result An array.  After calling this function,\n   *   result[0] will be the minimum value,\n   *   result[1] will be the maximum value.\n   */\n  function flattenPointsOn(points, normal, result) {\n    var min = Number.MAX_VALUE;\n    var max = -Number.MAX_VALUE;\n    var len = points.length;\n    for (var i = 0; i < len; i++ ) {\n      // The magnitude of the projection of the point onto the normal\n      var dot = points[i].dot(normal);\n      if (dot < min) { min = dot; }\n      if (dot > max) { max = dot; }\n    }\n    result[0] = min; result[1] = max;\n  }\n\n  // Check whether two convex polygons are separated by the specified\n  // axis (must be a unit vector).\n  /**\n   * @param {Vector} aPos The position of the first polygon.\n   * @param {Vector} bPos The position of the second polygon.\n   * @param {Array<Vector>} aPoints The points in the first polygon.\n   * @param {Array<Vector>} bPoints The points in the second polygon.\n   * @param {Vector} axis The axis (unit sized) to test against.  The points of both polygons\n   *   will be projected onto this axis.\n   * @param {Response=} response A Response object (optional) which will be populated\n   *   if the axis is not a separating axis.\n   * @return {boolean} true if it is a separating axis, false otherwise.  If false,\n   *   and a response is passed in, information about how much overlap and\n   *   the direction of the overlap will be populated.\n   */\n  function isSeparatingAxis(aPos, bPos, aPoints, bPoints, axis, response) {\n    var rangeA = T_ARRAYS.pop();\n    var rangeB = T_ARRAYS.pop();\n    // The magnitude of the offset between the two polygons\n    var offsetV = T_VECTORS.pop().copy(bPos).sub(aPos);\n    var projectedOffset = offsetV.dot(axis);\n    // Project the polygons onto the axis.\n    flattenPointsOn(aPoints, axis, rangeA);\n    flattenPointsOn(bPoints, axis, rangeB);\n    // Move B's range to its position relative to A.\n    rangeB[0] += projectedOffset;\n    rangeB[1] += projectedOffset;\n    // Check if there is a gap. If there is, this is a separating axis and we can stop\n    if (rangeA[0] > rangeB[1] || rangeB[0] > rangeA[1]) {\n      T_VECTORS.push(offsetV);\n      T_ARRAYS.push(rangeA);\n      T_ARRAYS.push(rangeB);\n      return true;\n    }\n    // This is not a separating axis. If we're calculating a response, calculate the overlap.\n    if (response) {\n      var overlap = 0;\n      // A starts further left than B\n      if (rangeA[0] < rangeB[0]) {\n        response['aInB'] = false;\n        // A ends before B does. We have to pull A out of B\n        if (rangeA[1] < rangeB[1]) {\n          overlap = rangeA[1] - rangeB[0];\n          response['bInA'] = false;\n        // B is fully inside A.  Pick the shortest way out.\n        } else {\n          var option1 = rangeA[1] - rangeB[0];\n          var option2 = rangeB[1] - rangeA[0];\n          overlap = option1 < option2 ? option1 : -option2;\n        }\n      // B starts further left than A\n      } else {\n        response['bInA'] = false;\n        // B ends before A ends. We have to push A out of B\n        if (rangeA[1] > rangeB[1]) {\n          overlap = rangeA[0] - rangeB[1];\n          response['aInB'] = false;\n        // A is fully inside B.  Pick the shortest way out.\n        } else {\n          var option1 = rangeA[1] - rangeB[0];\n          var option2 = rangeB[1] - rangeA[0];\n          overlap = option1 < option2 ? option1 : -option2;\n        }\n      }\n      // If this is the smallest amount of overlap we've seen so far, set it as the minimum overlap.\n      var absOverlap = Math.abs(overlap);\n      if (absOverlap < response['overlap']) {\n        response['overlap'] = absOverlap;\n        response['overlapN'].copy(axis);\n        if (overlap < 0) {\n          response['overlapN'].reverse();\n        }\n      }\n    }\n    T_VECTORS.push(offsetV);\n    T_ARRAYS.push(rangeA);\n    T_ARRAYS.push(rangeB);\n    return false;\n  }\n  SAT['isSeparatingAxis'] = isSeparatingAxis;\n\n  // Calculates which Voronoi region a point is on a line segment.\n  // It is assumed that both the line and the point are relative to `(0,0)`\n  //\n  //            |       (0)      |\n  //     (-1)  [S]--------------[E]  (1)\n  //            |       (0)      |\n  /**\n   * @param {Vector} line The line segment.\n   * @param {Vector} point The point.\n   * @return  {number} LEFT_VORONOI_REGION (-1) if it is the left region,\n   *          MIDDLE_VORONOI_REGION (0) if it is the middle region,\n   *          RIGHT_VORONOI_REGION (1) if it is the right region.\n   */\n  function voronoiRegion(line, point) {\n    var len2 = line.len2();\n    var dp = point.dot(line);\n    // If the point is beyond the start of the line, it is in the\n    // left voronoi region.\n    if (dp < 0) { return LEFT_VORONOI_REGION; }\n    // If the point is beyond the end of the line, it is in the\n    // right voronoi region.\n    else if (dp > len2) { return RIGHT_VORONOI_REGION; }\n    // Otherwise, it's in the middle one.\n    else { return MIDDLE_VORONOI_REGION; }\n  }\n  // Constants for Voronoi regions\n  /**\n   * @const\n   */\n  var LEFT_VORONOI_REGION = -1;\n  /**\n   * @const\n   */\n  var MIDDLE_VORONOI_REGION = 0;\n  /**\n   * @const\n   */\n  var RIGHT_VORONOI_REGION = 1;\n\n  // ## Collision Tests\n\n  // Check if a point is inside a circle.\n  /**\n   * @param {Vector} p The point to test.\n   * @param {Circle} c The circle to test.\n   * @return {boolean} true if the point is inside the circle, false if it is not.\n   */\n  function pointInCircle(p, c) {\n    var differenceV = T_VECTORS.pop().copy(p).sub(c['pos']).sub(c['offset']);\n    var radiusSq = c['r'] * c['r'];\n    var distanceSq = differenceV.len2();\n    T_VECTORS.push(differenceV);\n    // If the distance between is smaller than the radius then the point is inside the circle.\n    return distanceSq <= radiusSq;\n  }\n  SAT['pointInCircle'] = pointInCircle;\n\n  // Check if a point is inside a convex polygon.\n  /**\n   * @param {Vector} p The point to test.\n   * @param {Polygon} poly The polygon to test.\n   * @return {boolean} true if the point is inside the polygon, false if it is not.\n   */\n  function pointInPolygon(p, poly) {\n    TEST_POINT['pos'].copy(p);\n    T_RESPONSE.clear();\n    var result = testPolygonPolygon(TEST_POINT, poly, T_RESPONSE);\n    if (result) {\n      result = T_RESPONSE['aInB'];\n    }\n    return result;\n  }\n  SAT['pointInPolygon'] = pointInPolygon;\n\n  // Check if two circles collide.\n  /**\n   * @param {Circle} a The first circle.\n   * @param {Circle} b The second circle.\n   * @param {Response=} response Response object (optional) that will be populated if\n   *   the circles intersect.\n   * @return {boolean} true if the circles intersect, false if they don't.\n   */\n  function testCircleCircle(a, b, response) {\n    // Check if the distance between the centers of the two\n    // circles is greater than their combined radius.\n    var differenceV = T_VECTORS.pop().copy(b['pos']).add(b['offset']).sub(a['pos']).sub(a['offset']);\n    var totalRadius = a['r'] + b['r'];\n    var totalRadiusSq = totalRadius * totalRadius;\n    var distanceSq = differenceV.len2();\n    // If the distance is bigger than the combined radius, they don't intersect.\n    if (distanceSq > totalRadiusSq) {\n      T_VECTORS.push(differenceV);\n      return false;\n    }\n    // They intersect.  If we're calculating a response, calculate the overlap.\n    if (response) {\n      var dist = Math.sqrt(distanceSq);\n      response['a'] = a;\n      response['b'] = b;\n      response['overlap'] = totalRadius - dist;\n      response['overlapN'].copy(differenceV.normalize());\n      response['overlapV'].copy(differenceV).scale(response['overlap']);\n      response['aInB']= a['r'] <= b['r'] && dist <= b['r'] - a['r'];\n      response['bInA'] = b['r'] <= a['r'] && dist <= a['r'] - b['r'];\n    }\n    T_VECTORS.push(differenceV);\n    return true;\n  }\n  SAT['testCircleCircle'] = testCircleCircle;\n\n  // Check if a polygon and a circle collide.\n  /**\n   * @param {Polygon} polygon The polygon.\n   * @param {Circle} circle The circle.\n   * @param {Response=} response Response object (optional) that will be populated if\n   *   they interset.\n   * @return {boolean} true if they intersect, false if they don't.\n   */\n  function testPolygonCircle(polygon, circle, response) {\n    // Get the position of the circle relative to the polygon.\n    var circlePos = T_VECTORS.pop().copy(circle['pos']).add(circle['offset']).sub(polygon['pos']);\n    var radius = circle['r'];\n    var radius2 = radius * radius;\n    var points = polygon['calcPoints'];\n    var len = points.length;\n    var edge = T_VECTORS.pop();\n    var point = T_VECTORS.pop();\n\n    // For each edge in the polygon:\n    for (var i = 0; i < len; i++) {\n      var next = i === len - 1 ? 0 : i + 1;\n      var prev = i === 0 ? len - 1 : i - 1;\n      var overlap = 0;\n      var overlapN = null;\n\n      // Get the edge.\n      edge.copy(polygon['edges'][i]);\n      // Calculate the center of the circle relative to the starting point of the edge.\n      point.copy(circlePos).sub(points[i]);\n\n      // If the distance between the center of the circle and the point\n      // is bigger than the radius, the polygon is definitely not fully in\n      // the circle.\n      if (response && point.len2() > radius2) {\n        response['aInB'] = false;\n      }\n\n      // Calculate which Voronoi region the center of the circle is in.\n      var region = voronoiRegion(edge, point);\n      // If it's the left region:\n      if (region === LEFT_VORONOI_REGION) {\n        // We need to make sure we're in the RIGHT_VORONOI_REGION of the previous edge.\n        edge.copy(polygon['edges'][prev]);\n        // Calculate the center of the circle relative the starting point of the previous edge\n        var point2 = T_VECTORS.pop().copy(circlePos).sub(points[prev]);\n        region = voronoiRegion(edge, point2);\n        if (region === RIGHT_VORONOI_REGION) {\n          // It's in the region we want.  Check if the circle intersects the point.\n          var dist = point.len();\n          if (dist > radius) {\n            // No intersection\n            T_VECTORS.push(circlePos);\n            T_VECTORS.push(edge);\n            T_VECTORS.push(point);\n            T_VECTORS.push(point2);\n            return false;\n          } else if (response) {\n            // It intersects, calculate the overlap.\n            response['bInA'] = false;\n            overlapN = point.normalize();\n            overlap = radius - dist;\n          }\n        }\n        T_VECTORS.push(point2);\n      // If it's the right region:\n      } else if (region === RIGHT_VORONOI_REGION) {\n        // We need to make sure we're in the left region on the next edge\n        edge.copy(polygon['edges'][next]);\n        // Calculate the center of the circle relative to the starting point of the next edge.\n        point.copy(circlePos).sub(points[next]);\n        region = voronoiRegion(edge, point);\n        if (region === LEFT_VORONOI_REGION) {\n          // It's in the region we want.  Check if the circle intersects the point.\n          var dist = point.len();\n          if (dist > radius) {\n            // No intersection\n            T_VECTORS.push(circlePos);\n            T_VECTORS.push(edge);\n            T_VECTORS.push(point);\n            return false;\n          } else if (response) {\n            // It intersects, calculate the overlap.\n            response['bInA'] = false;\n            overlapN = point.normalize();\n            overlap = radius - dist;\n          }\n        }\n      // Otherwise, it's the middle region:\n      } else {\n        // Need to check if the circle is intersecting the edge,\n        // Change the edge into its \"edge normal\".\n        var normal = edge.perp().normalize();\n        // Find the perpendicular distance between the center of the\n        // circle and the edge.\n        var dist = point.dot(normal);\n        var distAbs = Math.abs(dist);\n        // If the circle is on the outside of the edge, there is no intersection.\n        if (dist > 0 && distAbs > radius) {\n          // No intersection\n          T_VECTORS.push(circlePos);\n          T_VECTORS.push(normal);\n          T_VECTORS.push(point);\n          return false;\n        } else if (response) {\n          // It intersects, calculate the overlap.\n          overlapN = normal;\n          overlap = radius - dist;\n          // If the center of the circle is on the outside of the edge, or part of the\n          // circle is on the outside, the circle is not fully inside the polygon.\n          if (dist >= 0 || overlap < 2 * radius) {\n            response['bInA'] = false;\n          }\n        }\n      }\n\n      // If this is the smallest overlap we've seen, keep it.\n      // (overlapN may be null if the circle was in the wrong Voronoi region).\n      if (overlapN && response && Math.abs(overlap) < Math.abs(response['overlap'])) {\n        response['overlap'] = overlap;\n        response['overlapN'].copy(overlapN);\n      }\n    }\n\n    // Calculate the final overlap vector - based on the smallest overlap.\n    if (response) {\n      response['a'] = polygon;\n      response['b'] = circle;\n      response['overlapV'].copy(response['overlapN']).scale(response['overlap']);\n    }\n    T_VECTORS.push(circlePos);\n    T_VECTORS.push(edge);\n    T_VECTORS.push(point);\n    return true;\n  }\n  SAT['testPolygonCircle'] = testPolygonCircle;\n\n  // Check if a circle and a polygon collide.\n  //\n  // **NOTE:** This is slightly less efficient than polygonCircle as it just\n  // runs polygonCircle and reverses everything at the end.\n  /**\n   * @param {Circle} circle The circle.\n   * @param {Polygon} polygon The polygon.\n   * @param {Response=} response Response object (optional) that will be populated if\n   *   they interset.\n   * @return {boolean} true if they intersect, false if they don't.\n   */\n  function testCirclePolygon(circle, polygon, response) {\n    // Test the polygon against the circle.\n    var result = testPolygonCircle(polygon, circle, response);\n    if (result && response) {\n      // Swap A and B in the response.\n      var a = response['a'];\n      var aInB = response['aInB'];\n      response['overlapN'].reverse();\n      response['overlapV'].reverse();\n      response['a'] = response['b'];\n      response['b'] = a;\n      response['aInB'] = response['bInA'];\n      response['bInA'] = aInB;\n    }\n    return result;\n  }\n  SAT['testCirclePolygon'] = testCirclePolygon;\n\n  // Checks whether polygons collide.\n  /**\n   * @param {Polygon} a The first polygon.\n   * @param {Polygon} b The second polygon.\n   * @param {Response=} response Response object (optional) that will be populated if\n   *   they interset.\n   * @return {boolean} true if they intersect, false if they don't.\n   */\n  function testPolygonPolygon(a, b, response) {\n    var aPoints = a['calcPoints'];\n    var aLen = aPoints.length;\n    var bPoints = b['calcPoints'];\n    var bLen = bPoints.length;\n    // If any of the edge normals of A is a separating axis, no intersection.\n    for (var i = 0; i < aLen; i++) {\n      if (isSeparatingAxis(a['pos'], b['pos'], aPoints, bPoints, a['normals'][i], response)) {\n        return false;\n      }\n    }\n    // If any of the edge normals of B is a separating axis, no intersection.\n    for (var i = 0;i < bLen; i++) {\n      if (isSeparatingAxis(a['pos'], b['pos'], aPoints, bPoints, b['normals'][i], response)) {\n        return false;\n      }\n    }\n    // Since none of the edge normals of A or B are a separating axis, there is an intersection\n    // and we've already calculated the smallest overlap (in isSeparatingAxis).  Calculate the\n    // final overlap vector.\n    if (response) {\n      response['a'] = a;\n      response['b'] = b;\n      response['overlapV'].copy(response['overlapN']).scale(response['overlap']);\n    }\n    return true;\n  }\n  SAT['testPolygonPolygon'] = testPolygonPolygon;\n\n  /* harmony default export */ __webpack_exports__[\"default\"] = (SAT);\n\n//# sourceURL=webpack:////storage/sdcard0/.htdocs/craters-beta/craters/Geometry/SAT.js?");

/***/ }),

/***/ "../../craters/Geometry/Vector.js":
/*!************************************************************************!*\
  !*** /storage/sdcard0/.htdocs/craters-beta/craters/Geometry/Vector.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Vector; });\n\n// Vector\n// ----------\n// Represents a vector in two dimensions with `x` and `y` properties.\n\n\n// Create a new Vector, optionally passing in the `x` and `y` coordinates. If\n// a coordinate is not specified, it will be set to `0`\n/**\n* @param {?number=} x The x position.\n* @param {?number=} y The y position.\n* @constructor\n*/\nfunction Vector(x, y) {\n\tthis['x'] = x || 0;\n\tthis['y'] = y || 0;\n}\n\n// Copy the values of another Vector into this one.\n/**\n* @param {Vector} other The other Vector.\n* @return {Vector} This for chaining.\n*/\nVector.prototype['copy'] = Vector.prototype.copy = function(other) {\n\tthis['x'] = other['x'];\n\tthis['y'] = other['y'];\n\treturn this;\n};\n\n// Create a new vector with the same coordinates as this on.\n/**\n* @return {Vector} The new cloned vector\n*/\nVector.prototype['clone'] = Vector.prototype.clone = function() {\n\treturn new Vector(this['x'], this['y']);\n};\n\n// Change this vector to be perpendicular to what it was before. (Effectively\n// roatates it 90 degrees in a clockwise direction)\n/**\n* @return {Vector} This for chaining.\n*/\nVector.prototype['perp'] = Vector.prototype.perp = function() {\n\tvar x = this['x'];\n\tthis['x'] = this['y'];\n\tthis['y'] = -x;\n\treturn this;\n};\n\n// Rotate this vector (counter-clockwise) by the specified angle (in radians).\n/**\n* @param {number} angle The angle to rotate (in radians)\n* @return {Vector} This for chaining.\n*/\nVector.prototype['rotate'] = Vector.prototype.rotate = function (angle) {\n\tvar x = this['x'];\n\tvar y = this['y'];\n\tthis['x'] = x * Math.cos(angle) - y * Math.sin(angle);\n\tthis['y'] = x * Math.sin(angle) + y * Math.cos(angle);\n\treturn this;\n};\n\n// Reverse this vector.\n/**\n* @return {Vector} This for chaining.\n*/\nVector.prototype['reverse'] = Vector.prototype.reverse = function() {\n\tthis['x'] = -this['x'];\n\tthis['y'] = -this['y'];\n\treturn this;\n};\n\n\n// Normalize this vector.  (make it have length of `1`)\n/**\n* @return {Vector} This for chaining.\n*/\nVector.prototype['normalize'] = Vector.prototype.normalize = function() {\n\tvar d = this.len();\n\tif(d > 0) {\n\t\tthis['x'] = this['x'] / d;\n\t\tthis['y'] = this['y'] / d;\n\t}\n\treturn this;\n};\n\n// Add another vector to this one.\n/**\n* @param {Vector} other The other Vector.\n* @return {Vector} This for chaining.\n*/\nVector.prototype['add'] = Vector.prototype.add = function(other) {\n\tthis['x'] += other['x'];\n\tthis['y'] += other['y'];\n\treturn this;\n};\n\n// Subtract another vector from this one.\n/**\n* @param {Vector} other The other Vector.\n* @return {Vector} This for chaiing.\n*/\nVector.prototype['sub'] = Vector.prototype.sub = function(other) {\n\tthis['x'] -= other['x'];\n\tthis['y'] -= other['y'];\n\treturn this;\n};\n\n// Scale this vector. An independent scaling factor can be provided\n// for each axis, or a single scaling factor that will scale both `x` and `y`.\n/**\n* @param {number} x The scaling factor in the x direction.\n* @param {?number=} y The scaling factor in the y direction.  If this\n*   is not specified, the x scaling factor will be used.\n* @return {Vector} This for chaining.\n*/\nVector.prototype['scale'] = Vector.prototype.scale = function(x,y) {\n\tthis['x'] *= x;\n\tthis['y'] *= typeof y != 'undefined' ? y : x;\n\treturn this;\n};\n\n// Project this vector on to another vector.\n/**\n* @param {Vector} other The vector to project onto.\n* @return {Vector} This for chaining.\n*/\nVector.prototype['project'] = Vector.prototype.project = function(other) {\n\tvar amt = this.dot(other) / other.len2();\n\tthis['x'] = amt * other['x'];\n\tthis['y'] = amt * other['y'];\n\treturn this;\n};\n\n// Project this vector onto a vector of unit length. This is slightly more efficient\n// than `project` when dealing with unit vectors.\n/**\n* @param {Vector} other The unit vector to project onto.\n* @return {Vector} This for chaining.\n*/\nVector.prototype['projectN'] = Vector.prototype.projectN = function(other) {\n\tvar amt = this.dot(other);\n\tthis['x'] = amt * other['x'];\n\tthis['y'] = amt * other['y'];\n\treturn this;\n};\n\n// Reflect this vector on an arbitrary axis.\n/**\n* @param {Vector} axis The vector representing the axis.\n* @return {Vector} This for chaining.\n*/\nVector.prototype['reflect'] = Vector.prototype.reflect = function(axis) {\n\tvar x = this['x'];\n\tvar y = this['y'];\n\tthis.project(axis).scale(2);\n\tthis['x'] -= x;\n\tthis['y'] -= y;\n\treturn this;\n};\n\n// Reflect this vector on an arbitrary axis (represented by a unit vector). This is\n// slightly more efficient than `reflect` when dealing with an axis that is a unit vector.\n/**\n* @param {Vector} axis The unit vector representing the axis.\n* @return {Vector} This for chaining.\n*/\nVector.prototype['reflectN'] = Vector.prototype.reflectN = function(axis) {\n\tvar x = this['x'];\n\tvar y = this['y'];\n\tthis.projectN(axis).scale(2);\n\tthis['x'] -= x;\n\tthis['y'] -= y;\n\treturn this;\n};\n\n// Get the dot product of this vector and another.\n/**\n* @param {Vector}  other The vector to dot this one against.\n* @return {number} The dot product.\n*/\nVector.prototype['dot'] = Vector.prototype.dot = function(other) {\n\treturn this['x'] * other['x'] + this['y'] * other['y'];\n};\n\n// Get the squared length of this vector.\n/**\n* @return {number} The length^2 of this vector.\n*/\nVector.prototype['len2'] = Vector.prototype.len2 = function() {\n\treturn this.dot(this);\n};\n\n// Get the length of this vector.\n/**\n* @return {number} The length of this vector.\n*/\nVector.prototype['len'] = Vector.prototype.len = function() {\n\treturn Math.sqrt(this.len2());\n};\n\n//# sourceURL=webpack:////storage/sdcard0/.htdocs/craters-beta/craters/Geometry/Vector.js?");

/***/ }),

/***/ "../../craters/Modules/Assets/Image.js":
/*!*****************************************************************************!*\
  !*** /storage/sdcard0/.htdocs/craters-beta/craters/Modules/Assets/Image.js ***!
  \*****************************************************************************/
/*! exports provided: loadImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadImage\", function() { return loadImage; });\nclass loadImage {\n\tconstructor() {\n\t\tthis.instances = {}\n\t};\n\t\n\tload(resource, callback) {\n\t\tif (resource instanceof Array) {\n\t\t\tif(resource.length < 0) return this.ready(callback);\n\t\t\tresource.forEach((i) => {\n\t\t\t\tthis.instances[i] = false\n\t\t\t\tthis.fetch(i, callback)\n\t\t\t})\n\t\t} else {\n\t\t\tthis.instances[resource] = false\n\t\t\tthis.fetch(resource, callback)\n\t\t}\n\t}\n\t\n\tfetch(path, callback) {\n\t\tif (this.instances[path]) {\n\t\treturn this.instances[path]\n\t\t} else {\n\t\t\tlet img = new Image()\n\t\t\timg.onload = () => {\n\t\t\t\tthis.instances[path] = img\n\t\t\t\tthis.ready(callback)\n\t\t\t}\n\t\t\timg.src = path;\n\t\t}\n\t}\n\t\n\tready(callback) {\n\t\tif (typeof callback === 'function') {\n\t\tlet ready = true;\n\t\tfor (let item in this.instances) {\n\t\t\tif (Object.prototype.hasOwnProperty.call(this.instances, item) && !this.instances[item]) {\n\t\t\t\tready = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (ready) callback();\n\t\t}\n\t}\n}\n\n//# sourceURL=webpack:////storage/sdcard0/.htdocs/craters-beta/craters/Modules/Assets/Image.js?");

/***/ }),

/***/ "../../craters/Modules/Tilemap/Tile.js":
/*!*****************************************************************************!*\
  !*** /storage/sdcard0/.htdocs/craters-beta/craters/Modules/Tilemap/Tile.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Tile; });\n/* harmony import */ var _Texture_Textures_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Texture/Textures.js */ \"../../craters/Texture/Textures.js\");\n/* harmony import */ var _Fixture_Fixtures_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Fixture/Fixtures.js */ \"../../craters/Fixture/Fixtures.js\");\n/* harmony import */ var _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Geometry/Geometry.js */ \"../../craters/Geometry/Geometry.js\");\n\n\n\n\nclass Tile {\n\tconstructor(context, params, args) {\n\t\tlet vec = _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_2__[\"Vector\"];\n\t\tlet num = Number;\n\t\tlet obj = Object;\n\t\tlet str = String;\n\t\tlet arr = Array;\n\t\t\n\t\tthis.state = {\n\t\t// properties\n\t\t}\n\t\tthis.collision = {\n\t\tcollides: true\n\t\t}\n\t\tthis.type = 'kinematic';\n\t\tthis.context = context;\n\t\tparams = params || new obj({\n\t\t// texture properties\n\t\t})\n\t\tparams.style = params.style || new obj({\n\t\t// texture style properties\n\t\t})\n\t\tparams.style.fillStyle = params.style.fillStyle || new str(\"#ddd\")\n\t\tparams.style.lineWidth = params.style.lineWidth || new num(2)\n\t\tparams.style.strokeStyle = params.style.strokeStyle || new str(\"#333\")\n\t\tparams.frames = [Math.floor(args[0])]\n\t\t// params.image = null;\n\t\t// [tileId, row, col, tileset]\n\t\tthis.state.position = new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_2__[\"Vector\"](params.tilewidth * args[1], params.tileheight * args[2])\n\t\t// console.log(this.state)\n\t\t// Todo circles too\n\t\tthis.fixture = new _Fixture_Fixtures_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Polygon(this.state.position, [{x:0, y:0}, {x:0, y:params.tileheight}, {x:params.tilewidth, y:params.tileheight}, {x:params.tilewidth, y:0}]);\n\t\tthis.texture = new _Texture_Textures_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Sprite(this, params);\n\t}\n};\n\n//# sourceURL=webpack:////storage/sdcard0/.htdocs/craters-beta/craters/Modules/Tilemap/Tile.js?");

/***/ }),

/***/ "../../craters/Modules/Tilemap/Tilemap.js":
/*!********************************************************************************!*\
  !*** /storage/sdcard0/.htdocs/craters-beta/craters/Modules/Tilemap/Tilemap.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Tilemap; });\n/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tile.js */ \"../../craters/Modules/Tilemap/Tile.js\");\n\n\n// tilemap add (tilesheet)\nclass Tilemap {\n\tconstructor(params, context, quad) {\n\t\tthis.tilemaps = [];\n\t\tthis.level = null;\n\t\tthis.quad = quad;\n\t\tthis.pool = [];\n\t\tthis.context = context;\n\t}\n\t\n\t__load(tilemap) {\n\t\tlet tilesets = [];\n\t\tthis.pool = [];\n\t\t// parser\n\t\ttilemap.tilesets.forEach((params) => {\n\t\t\t// make a tile\n\t\t\ttilesets.push(params)\n\t\t});\n\t\t// populate\n\t\ttilemap.layers.forEach((layer) => {\n\t\t\tlayer.data.forEach((tile) => {\n\t\t\t// make an instance of a tile\n\t\t\t// array [tileId, row, col, tileset]\n\t\t\tlet params = tilesets[tile[3]];\n\t\t\tlet img\t= new Image()\n\t\t\timg.src = params.image;\n\t\t\timg.onload = () => {\n\t\t\t\tparams.image = img;\n\t\t\t\t\tlet tiles = new _Tile_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.context, params, tile);\n\t\t\t\t\tthis.quad.insert(tiles)\n\t\t\t\t\tthis.pool.push(tiles)\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\t\n\tload(tilemap, name) {\n\t\tthis.tilemaps[name] = tilemap;\n\t}\n\t\n\tset(name) {\n\t\tif(!this.tilemaps[name]) return;\n\t\tthis.__load(this.tilemaps[name]);\n\t}\n\t\n\tupdate(params) {\n\t\tthis.pool.forEach((tile) => {\n\t\t\tlet item = tile;\n\t\t\tlet bounds = item.fixture.getAABB();\n\t\t\tlet edges = bounds.edges;\n\t\t\tlet width = (edges[0].x - edges[2].x) / 2,\n\t\t\t    height = (edges[1].y - edges[3].y) / 2;\n\t\t\tlet position = item.state.position;\n\t\t\tlet x = position.x,\n\t\t\t    y = position.y;\n\t\t\tif(item.fixture.type == \"circle\")\n\t\t\tx = position.x - (width / 2),\n\t\t\ty = position.y - (height / 2);\n\n\t\t\tthis.quad.insert({x , y , width, height, item})\n\t\t\titem.texture.update();\n\t\t})\n\t}\n\t\n\trender(params) {\n\t\tthis.pool.forEach((tile) => {\n\t\t\ttile.texture.render();\n\t\t})\n\t}\n};\n\n//# sourceURL=webpack:////storage/sdcard0/.htdocs/craters-beta/craters/Modules/Tilemap/Tilemap.js?");

/***/ }),

/***/ "../../craters/Polyfill.js":
/*!*****************************************************************!*\
  !*** /storage/sdcard0/.htdocs/craters-beta/craters/Polyfill.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, setImmediate) {// for nodejs environment\n// the script creates an equivalent of \n// requestAnimationFrame function\n\nvar cg = new Object();\nif (typeof window === 'undefined' && global) {\n    global.window = {\n        performance: {\n            now: function(start) {\n                if (!start) return Date.now()\n                var end = Date.now(start)\n                return Math.round((end[0] * 1000) + (end[1] / 1000000))\n            }\n        },\n        requestAnimationFrame: function(f) {\n            setImmediate(() => f(this.performance.now()))\n        }\n    }\n}\n\n// assingn cg to window object\nwindow['cg'] = cg;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../usr/lib/node_modules/webpack/buildin/global.js */ \"../../../../../../usr/lib/node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../../../usr/lib/node_modules/webpack/node_modules/timers-browserify/main.js */ \"../../../../../../usr/lib/node_modules/webpack/node_modules/timers-browserify/main.js\").setImmediate))\n\n//# sourceURL=webpack:////storage/sdcard0/.htdocs/craters-beta/craters/Polyfill.js?");

/***/ }),

/***/ "../../craters/System.js":
/*!***************************************************************!*\
  !*** /storage/sdcard0/.htdocs/craters-beta/craters/System.js ***!
  \***************************************************************/
/*! exports provided: Loop, Canvas */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Loop\", function() { return Loop; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Canvas\", function() { return Canvas; });\n// Game Loop Module\n// This module contains the game loop, which handles\n// updating the game state and re-rendering the canvas\n// (using the updated state) at the configured tframe.\nclass Loop {\n    constructor(scope, tframe) {\n        var loop = {\n            delta: (1000 / tframe),\n            elapsed: 0,\n            tframe: (1000 / tframe),\n            nframe: tframe,\n            before: window.performance.now()\n        }\n        // Initialize timer variables so we can calculate tframe\n        // Main game rendering loop\n        loop.main = function() {\n            loop.startLoop = window.requestAnimationFrame(loop.main)\n            loop.delta = Math.round(((1000 / (window.performance.now() - loop.before) * 100) / 100))\n\n            if (window.performance.now() < loop.before + loop.tframe) return\n            loop.before = window.performance.now()\n            // Request a new Animation Frame\n            // setting to `stopLoop` so animation can be stopped via\n            loop.stopLoop = () => {\n                window.cancelAnimationFrame(loop.startLoop)\n            }\n            // update scope\n            if(scope.state)\n            scope.state.loop = loop;\n\n            // Update the game state\n            scope.update(loop.elapsed, loop.delta)\n            // Render the next frame\n            scope.render(loop.elapsed, loop.delta)\n            loop.elapsed++\n        }\n\n        // Start off main loop\n        loop.main()\n        return loop\n    }\n}\n\nclass Canvas {\n    constructor(width, height, container) {\n        container = document.querySelector(container || 'body')\n        // Generate a canvas and store it as our viewport\n        var canvas = document.createElement('canvas')\n        var context = canvas.getContext('2d')\n        // Pass our canvas' context to our getPixelRatio method\n        var backingStores = ['webkitBackingStorePixelRatio', 'mozBackingStorePixelRatio', 'msBackingStorePixelRatio', 'oBackingStorePixelRatio', 'backingStorePixelRatio']\n        var deviceRatio = window.devicePixelRatio\n        // Iterate through our backing store props and determine the proper backing ratio.\n        var backingRatio = backingStores.reduce(function(prev, curr) {\n            return (Object.prototype.hasOwnProperty.call(context, curr) ? context[curr] : 1)\n        })\n        // Return the proper pixel ratio by dividing the device ratio by the backing ratio\n        var ratio = deviceRatio / backingRatio\n\n        // Set the canvas' width then downscale via CSS\n        canvas.width = Math.round(width * ratio)\n        canvas.height = Math.round(height * ratio)\n        canvas.style.width = width + 'px'\n        canvas.style.height = height + 'px'\n        // Scale the context so we get accurate pixel density\n        context.setTransform(ratio, 0, 0, ratio, 0, 0)\n        // Append viewport into our game within the dom\n        container.insertBefore(canvas, container.firstChild)\n        canvas.context = canvas.getContext('2d')\n\n        canvas.resize = (scope, size) => {\n            canvas.style.width = size.x + 'px'\n            canvas.style.height = size.y + 'px'\n            canvas.width = Math.round(size.x * ratio)\n            canvas.height = Math.round(size.y * ratio)\n            context.setTransform(ratio, 0, 0, ratio, 0, 0)\n\n            scope.state.size.x = size.x\n            scope.state.size.y = size.y\n        }\n\n        canvas.clear = (v, w, x, y, z) => {\n            v = v || null\n            w = w || 0\n            x = x || 0\n            y = y || canvas.width\n            z = z || canvas.height\n\n            if (v) { // clear with color if true\n                canvas.context.save();\n                canvas.context.fillStyle = v;\n                canvas.context.fillRect(w, x, y, z)\n                canvas.context.fill();\n                canvas.context.restore();\n            } else {\n                canvas.context.clearRect(w, x, y, z)\n            };\n        }\n\n        canvas.camera = (x, y) => {\n            canvas.context.setTransform(1, 0, 0, 1, 0, 0) // reset the transform matrix\n            canvas.context.translate(-x, -y)\n        }\n\n        return canvas // return the canvas\n    }\n}\n\n//# sourceURL=webpack:////storage/sdcard0/.htdocs/craters-beta/craters/System.js?");

/***/ }),

/***/ "../../craters/Texture/Solid.js":
/*!**********************************************************************!*\
  !*** /storage/sdcard0/.htdocs/craters-beta/craters/Texture/Solid.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Solid; });\nclass Solid {\n\tconstructor(body, params) {\n\t\tthis.body = body;\n\t\tthis.style = params.style;\n\t\tthis.fixture = body.fixture;\n\t\tthis.position = body.state.position;\n\t}\n\t\n\tupdate(){\n\t\n\t}\n\t\n\trender() {\n\tlet body = this.body;\n\tlet context = body.context;\n\tcontext.fillStyle = this.style.fillStyle;\n\tcontext.lineWidth = this.style.lineWidth;\n\tcontext.strokeStyle = this.style.strokeStyle;\n\tcontext.lineJoin = 'miter';\n\t\n\tswitch (body.fixture.type) {\n\t\t    case 'circle': {\n\t\t\t\tcontext.beginPath();\n\t\t\t\tcontext.ellipse(\n\t\t\t        body.state.position.x,\n\t\t\t        body.state.position.y,\n\t\t\t        body.fixture.r,\n\t\t\t        body.fixture.r,\n\t\t\t        0, 0,\n\t\t\t        Math.PI * 2\n\t\t        );\n\t\t        context.closePath();\n\t\t        context.stroke();\n\t\t        context.fill();\n\t\t        break;\n\t\t    }\n\t\t    case 'polygon': {\n\t\t        context.beginPath();\n\t\t        // console.log(JSON.stringify(body.fixture.points))\n\t\t        context.moveTo(body.state.position.x + body.fixture.points[0].x, body.state.position.y + body.fixture.points[0].y);\n\t\t        for (let i = 1; i < body.fixture.points.length; i++) {\n\t\t\t        let v = body.fixture.points[i];\n\t\t\t        context.lineTo(body.state.position.x + v.x, body.state.position.y + v.y);\n\t\t        };\n\t\t        context.lineTo(body.state.position.x + body.fixture.points[0].x, body.state.position.y + body.fixture.points[0].y);\n\t\t        context.fill();\n\t\t        context.stroke();\n\t\t        break;\n\t\t    }\n\t\t}\n\t}\n}\n\n//# sourceURL=webpack:////storage/sdcard0/.htdocs/craters-beta/craters/Texture/Solid.js?");

/***/ }),

/***/ "../../craters/Texture/Sprite.js":
/*!***********************************************************************!*\
  !*** /storage/sdcard0/.htdocs/craters-beta/craters/Texture/Sprite.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Sprite; });\nclass Sprite {\n\tconstructor(object, params) {\n\t\tthis.size = {\n\t\t\tx: params.tilewidth,\n\t\t\ty: params.tileheight\n\t\t}\n\t\t\n\t\tthis.frame;\n\t\tthis.grid = [];\n\t\tthis.image = params.image;\n\t\tthis.object = object;\n\t\tthis.style = params.style;\n\t\tthis.fixture = object.fixture;\n\t\tthis.position = object.state.position;\n\t\tparams.frames = params.frames || [0];\n\t\t\n\t\tif(this.image instanceof Image) {\n\t\t\t\n\t\t\tfor(let h = 0; h < this.image.height; h += this.size.y){\n\t\t\tfor(let w = 0; w < this.image.width; w += this.size.x){\n\t\t\t\tthis.grid.push({x: w, y: h})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.animation = {frames: params.frames}\n\t}\n\t\n\tupdate() {\n\t\tthis.frame = this.animation.frames.shift()\n\t\tthis.animation.frames.push(this.frame)\n\t}\n\t\n\trender() {\n\tlet object = this.object;\n\tlet image = this.image;\n\tlet context = object.context;\n\tcontext.fillStyle = this.style.fillStyle;\n\tcontext.lineWidth = this.style.lineWidth;\n\tcontext.strokeStyle = this.style.strokeStyle;\n\tcontext.lineJoin = 'miter';\n\t\n\tswitch (object.fixture.type) {\n\t\t    case 'circle': {\n\t\t\t\tcontext.save();\n\t\t\t\tcontext.beginPath();\n\t\t\t\tcontext.ellipse(\n\t\t\t        object.state.position.x,\n\t\t\t        object.state.position.y,\n\t\t\t        object.fixture.r,\n\t\t\t        object.fixture.r,\n\t\t\t        0, 0,\n\t\t\t        Math.PI * 2\n\t\t        );\n\t\t        context.clip();\n\t\t        let frame = this.frame;\n\t\t        if(image instanceof Image) {\n\t\t        context.drawImage(this.image,\n\t\t\t        this.grid[frame].x, this.grid[frame].y, this.size.x, this.size.y,\n\t\t\t        object.state.position.x - object.fixture.r, object.state.position.y - object.fixture.r, this.size.x, this.size.y\n\t\t        )}\n\t\t        else {\n\t\t\t        context.fill();\n\t\t\t        context.stroke();\n\t\t        }\n\t\t        context.closePath();\n\t\t        context.restore();\n\t\t        break;\n\t\t    }\n\t\t    case 'polygon': {\n\t\t\t    context.save();\n\t\t        context.beginPath();\n\t\t        context.moveTo(object.state.position.x + object.fixture.points[0].x, object.state.position.y + object.fixture.points[0].y);\n\t\t        for (let i = 1; i < object.fixture.points.length; i++) {\n\t\t\t        let v = object.fixture.points[i];\n\t\t\t        context.lineTo(object.state.position.x + v.x, object.state.position.y + v.y);\n\t\t        };\n\t\t        context.lineTo(object.state.position.x + object.fixture.points[0].x, object.state.position.y + object.fixture.points[0].y);\n\t\t        context.clip();\n\t\t        let frame = this.frame;\n\t\t        if(image instanceof Image) {\n\t\t\t        context.drawImage(this.image,\n\t\t\t        this.grid[frame].x, this.grid[frame].y, this.size.x, this.size.y,\n\t\t\t        object.state.position.x, object.state.position.y, this.size.x, this.size.y\n\t\t        )}\n\t\t        else {\n\t\t\t        context.fill();\n\t\t\t        context.stroke();\n\t\t        }\n\t\t        context.closePath();\n\t\t        context.restore();\n\t\t        break;\n\t\t    }\n\t\t}\n\t}\n}\n\n//# sourceURL=webpack:////storage/sdcard0/.htdocs/craters-beta/craters/Texture/Sprite.js?");

/***/ }),

/***/ "../../craters/Texture/Textures.js":
/*!*************************************************************************!*\
  !*** /storage/sdcard0/.htdocs/craters-beta/craters/Texture/Textures.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Solid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Solid.js */ \"../../craters/Texture/Solid.js\");\n/* harmony import */ var _Sprite_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Sprite.js */ \"../../craters/Texture/Sprite.js\");\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({Solid: _Solid_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"], Sprite: _Sprite_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]});\n\n//# sourceURL=webpack:////storage/sdcard0/.htdocs/craters-beta/craters/Texture/Textures.js?");

/***/ }),

/***/ "../../craters/craters.js":
/*!****************************************************************!*\
  !*** /storage/sdcard0/.htdocs/craters-beta/craters/craters.js ***!
  \****************************************************************/
/*! exports provided: Craters, Game, Entity, Fixtures, Vector, Maths */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Craters\", function() { return Craters; });\n/* harmony import */ var _Polyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Polyfill.js */ \"../../craters/Polyfill.js\");\n/* harmony import */ var _Polyfill_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Polyfill_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Entity_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Entity.js */ \"../../craters/Entity.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Entity\", function() { return _Entity_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; });\n\n/* harmony import */ var _Game_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Game.js */ \"../../craters/Game.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Game\", function() { return _Game_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; });\n\n/* harmony import */ var _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Geometry/Geometry.js */ \"../../craters/Geometry/Geometry.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Maths\", function() { return _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_3__[\"Maths\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Vector\", function() { return _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_3__[\"Vector\"]; });\n\n/* harmony import */ var _Fixture_Fixtures_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Fixture/Fixtures.js */ \"../../craters/Fixture/Fixtures.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Fixtures\", function() { return _Fixture_Fixtures_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]; });\n\n// Craters.js micro game framework\n// This module contains the core craters.js framework fundamentals\n// it loads modules and exports them\n\n\n\n\n\n\n\n\nclass Craters {\n    static version() {\n        return '1.2.2'\n    }\n}\n\n\n\n//# sourceURL=webpack:////storage/sdcard0/.htdocs/craters-beta/craters/craters.js?");

/***/ }),

/***/ "./game.js":
/*!*****************!*\
  !*** ./game.js ***!
  \*****************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _craters_craters__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../craters/craters */ \"../../craters/craters.js\");\n/* harmony import */ var _craters_Modules_Assets_Image_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../craters/Modules/Assets/Image.js */ \"../../craters/Modules/Assets/Image.js\");\n\n\n// Game\nclass mygame extends _craters_craters__WEBPACK_IMPORTED_MODULE_0__[\"Game\"] {\n    constructor(container, width, height) {\n\t\tsuper({\n\t        debug: false,\n\t        fps: 60,\n\t        container: '#container',\n\t        size: new _craters_craters__WEBPACK_IMPORTED_MODULE_0__[\"Vector\"](500, 500),\n\t        hash: new _craters_craters__WEBPACK_IMPORTED_MODULE_0__[\"Vector\"](50, 50),\n\t        resources: {image: ['./bug.png'], data: ['./map.json']}\n        });\n        \n        this.viewport.style.background = \"#eee\";\n        this.viewport.resize(this, {\n            x: window.innerWidth,\n            y: window.innerHeight\n        });\n        \n        // this.state.gravity = new Vector(0, 0.01)\n        // add some marbles\n        for (var i = 0; i < 10; i++) {\n            let id = this.addObject(new marble(this)) - 1\n            this.entities[id].id = id;\n        }\n    }\n\n    render() {\n        super.render()\n    }\n}\n\n// Marble\nclass marble extends _craters_craters__WEBPACK_IMPORTED_MODULE_0__[\"Entity\"] {\n    constructor(scope) {\n        let params = {\n\t        debug: false,\n\t        texture: {\n\t\t        style: {\n\t\t\t        fillStyle: \"green\",\n\t\t\t        strokeStyle: \"white\"\n\t\t        },\n\t\t        /*frames: [0],\n\t\t        tileheight: '196',\n\t\t        tilewidth: '218',\n\t\t        image: sprite.fetch('./bug.png')*/\n\t        },\n\t        velocity: new _craters_craters__WEBPACK_IMPORTED_MODULE_0__[\"Vector\"](((Math.random() - 0.5) * 300), ((Math.random() - 0.5) * 300))\n        }\n        super(params);\n        \n        this.scope = scope;\n        this.state.position.x = ((Math.random()) * this.scope.state.size.x)\n        this.state.position.y = ((Math.random()) * this.scope.state.size.y)\n        this.fixture = (Math.random() < 0.5) ? new _craters_craters__WEBPACK_IMPORTED_MODULE_0__[\"Fixtures\"].Circle(this.state.position, 50) : new _craters_craters__WEBPACK_IMPORTED_MODULE_0__[\"Fixtures\"].Polygon(this.state.position, [{x:0, y:0}, {x:0, y:50}, {x:50, y:50}, {x:50, y:0}]);\n        this.fixture.r = this.fixture.r || 0;\n    }\n    update() {\n\t    // X-axis collision\n\t    if ((this.state.position.x + this.fixture.r > this.scope.state.size.x)) {\n\t    if (this.state.velocity.x < 0) return\n\t\t    this.state.velocity.x *= -1\n\t    }\n\t    // Y-axis collision\n\t    if ((this.state.position.y + this.fixture.r > this.scope.state.size.y)) {\n\t    if (this.state.velocity.y < 0) return\n\t\t    this.state.velocity.y *= -1\n\t    }\n\t    \n\t    if ((this.state.position.x - this.fixture.r < 0)) {\n\t    if (this.state.velocity.x > 0) return\n\t\t    this.state.velocity.x *= -1\n\t    }\n\t    // Y-axis collision\n\t    if ((this.state.position.y - this.fixture.r < 0)) {\n\t    if (this.state.velocity.y > 0) return\n\t\t    this.state.velocity.y *= -1\n\t    }\n    }\n    render() {\n\t\tsuper.render();\n\t\t\n    }\n}\n\nlet sprite = new _craters_Modules_Assets_Image_js__WEBPACK_IMPORTED_MODULE_1__[\"loadImage\"]()\nlet image = sprite.load('./bug.png', () => {\n\tlet game = new mygame('#container', 1024, 512)\n});\n\n//# sourceURL=webpack:///./game.js?");

/***/ })

/******/ });