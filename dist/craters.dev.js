/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Collision/Broadphase.js":
/*!*************************************!*\
  !*** ./src/Collision/Broadphase.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Broadphase)\n/* harmony export */ });\nclass Broadphase {\n    // \n    static collides(collider, collidee) {\n        if (collider.collision.collides && collidee.collision.collides) {\n            // TODO: \n            // additionally check group \n            return true;\n        }\n        return false;\n    }\n    \n    static query(collidee, quad) {\n\t    let collideds = [];\n\t    let collided = quad.retrieve(collidee);\n\t    collided.forEach((item) => {collideds.push(item.item)})\n\t    return collideds;\n    }\n}\n\n//# sourceURL=webpack://craters/./src/Collision/Broadphase.js?");

/***/ }),

/***/ "./src/Collision/Narrowphase.js":
/*!**************************************!*\
  !*** ./src/Collision/Narrowphase.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Narrowphase)\n/* harmony export */ });\n/* harmony import */ var _Geometry_SAT_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Geometry/SAT.js */ \"./src/Geometry/SAT.js\");\n\n\nclass Narrowphase {\n    static overlap(collider, collidee) {\n        return true;\n    }\n    \n    static query(collidee, colliders) {\n\t    let collided = [];\n\t    \n\t    colliders.forEach((collider) => {\n\t\t    if(this.overlap(collider, collidee))\n\t\t    collided.push(collider)\n\t    })\n\t    \n\t    return collided;\n    }\n}\n\n//# sourceURL=webpack://craters/./src/Collision/Narrowphase.js?");

/***/ }),

/***/ "./src/Collision/Solver.js":
/*!*********************************!*\
  !*** ./src/Collision/Solver.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Solver)\n/* harmony export */ });\n/* harmony import */ var _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Geometry/Geometry.js */ \"./src/Geometry/Geometry.js\");\n/* harmony import */ var _Fixture_Circle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Fixture/Circle.js */ \"./src/Fixture/Circle.js\");\n/* harmony import */ var _Fixture_Polygon_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Fixture/Polygon.js */ \"./src/Fixture/Polygon.js\");\n/* harmony import */ var _Geometry_SAT_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Geometry/SAT.js */ \"./src/Geometry/SAT.js\");\n\n\n\n\n\nclass Solver {\n\tconstructor() {\n\t\tthis.response = new _Geometry_SAT_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].Response(); // Response reused for collisions\n\t}\n\tresolve(collidee, colliders) {\n\t\tcolliders.forEach((collider) => {\n\t\t\tlet collided;\n\t\t\tif (collider.fixture instanceof _Fixture_Circle_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\n\t\t\t\tif (collidee.fixture instanceof _Fixture_Circle_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\n\t\t\t\t\tcollided = _Geometry_SAT_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].testCircleCircle(collider.fixture, collidee.fixture, this.response);\n\t\t\t\t} else {\n\t\t\t\t\tcollided = _Geometry_SAT_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].testCirclePolygon(collider.fixture, collidee.fixture, this.response);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (collidee.fixture instanceof _Fixture_Circle_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\n\t\t\t\t\tcollided = _Geometry_SAT_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].testPolygonCircle(collider.fixture, collidee.fixture, this.response);\n\t\t\t\t} else {\n\t\t\t\t\tcollided = _Geometry_SAT_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].testPolygonPolygon(collider.fixture, collidee.fixture, this.response);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (collided) {\n\t\t\t\t// TODO look into this\n\t\t\t\tif (collider.type == 'kinematic') {\n\t\t\t\t  // Move the collidee object out of us\n\t\t\t\t  collidee.state.position.add(this.response.overlapV);\n\t\t\t\t  collidee.state.velocity.add(this.response.overlapV);\n\t\t\t\t} else if (collidee.type == 'kinematic') {\n\t\t\t\t  // Move us out of the collidee object\n\t\t\t\t  collider.state.position.sub(this.response.overlapV);\n\t\t\t\t  collider.state.velocity.sub(this.response.overlapV);\n\t\t\t\t} else {\n\t\t\t\t  // Move equally out of each collidee\n\t\t\t\t  this.response.overlapV.scale(0.5);\n\t\t\t\t  collider.state.position.sub(this.response.overlapV);\n\t\t\t\t  collidee.state.position.add(this.response.overlapV);\n\t\t\t\t  \n\t\t\t\t  collider.state.velocity.sub(this.response.overlapV);\n\t\t\t\t  collidee.state.velocity.add(this.response.overlapV);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.response.clear();\n\t\t})\n\t}\n};\n\n//# sourceURL=webpack://craters/./src/Collision/Solver.js?");

/***/ }),

/***/ "./src/Entity.js":
/*!***********************!*\
  !*** ./src/Entity.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Entity)\n/* harmony export */ });\n/* harmony import */ var _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Geometry/Geometry.js */ \"./src/Geometry/Geometry.js\");\n/* harmony import */ var _Texture_Textures_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Texture/Textures.js */ \"./src/Texture/Textures.js\");\n\n\n\nclass Entity {\n    constructor(params) {\n\t\t// define shortcuts \n\t\tlet vec = _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__.Vector;\n\t\tlet num = Number;\n\t\tlet obj = Object;\n\t\tlet str = String;\n\t\tlet arr = Array;\n\t\t\n\t\tparams.debug = params.debug || false;\n\t\tparams.position = params.position || new vec()\n\t\tparams.angle = params.angle || new num();\n\t\tparams.maxVelocity = params.maxVelocity || new vec(200, 200)\n\t\tparams.velocity = params.velocity || new vec()\n\t\tparams.acceleration = params.acceleration || new vec()\n\t\tparams.mass = params.mass || new num(1);\n\t\tparams.force = params.force || new vec()\n\t\tparams.texture = params.texture || new obj({\n\t\t\t// texture properties\n\t\t})\n\t\tparams.texture.style = params.texture.style || new obj({\n\t\t\t// texture style properties\n\t\t})\n\t\tparams.texture.style.fillStyle = params.texture.style.fillStyle || new str(\"#ddd\")\n\t\tparams.texture.style.lineWidth = params.texture.style.lineWidth || new num(2)\n\t\tparams.texture.style.strokeStyle = params.texture.style.strokeStyle || new str(\"#333\")\n\t\t\n\t\tthis.debug = params.debug;\n\t\tthis.state = {\n\t\t\t// an object storing\n\t\t\t// entity properties\n\t\t}\n\t\tthis.state.position = params.position\n\t\tthis.state.angle = params.angle\n\t\t\n\t\tparams.collision = params.collision || new obj({\n\t\t\t// collision properties\n\t\t})\n\t\t// default collision properties\n\t\tparams.collision.collides = params.collision.collides || true;\n\t\tparams.collision.group = params.collision.group || new arr(['everyone']);\n\t\tparams.collision.checkAgenist = params.collision.checkAgenist || new arr(['everyone']);\n\t\tparams.gravityFactor = params.gravityFactor || new vec(1, 1)\n\t\t\n\t\t// collision properties\n\t\tthis.collision = {\n\t\t\tcollides: params.collision.collides,\n\t\t\tgroup: params.collision.group,\n\t\t\tcheckAgenist: params.collision.checkAgenist\n\t\t}\n\t\t\n\t\t// body dynamics\n\t\tthis.state.force = params.force\n\t\tthis.gravityFactor = params.gravityFactor\n\t\t// mass\n\t\tthis.state.mass = params.mass\n        // body kinematics\n        this.state.maxVelocity = params.maxVelocity\n        this.state.velocity = params.velocity\n        this.state.acceleration = params.acceleration\n        \n        // body type\n        this.types = {\n\t        kinematic: 'kinematic',\n\t        dynamic: 'dynamic'\n        }\n        \n        // set default body type\n        this.type = params.type;\n        \n        // fixture\n        this.fixture = {\n\t        // friction\n\t        // size\n\t        // density\n\t        // material\n        }\n        \n        // body texture\n        this.texture = new _Texture_Textures_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Sprite(this, params.texture);\n    }\n    \n    // update own state\n    update () {\n    \n    }\n    \n    // render own state\n    render() {\n\t    let style = this.texture.style;\n\t    let context = this.context;\n\t    \n\t    if(this.debug) {\n\t    // Todo more tools , centroid.\n\t    context.save()\n\t    context.beginPath();\n\t    context.strokeStyle = \"red\";\n\t    context.lineWidth = \"1\";\n\t    \n\t    let bounds = this.fixture.getAABB();\n\t    let edges = bounds.edges;\n\t    let width = (edges[0].x - edges[2].x) / 2,\n\t\t    height = (edges[1].y - edges[3].y) / 2;\n\t    let position = this.state.position;\n\t    let x = position.x,\n\t\t    y = position.y;\n\t    if(this.fixture.type == \"circle\")\n\t    x = position.x - (width / 2),\n\t\ty = position.y - (height / 2);\n\t    \n\t    context.rect(x , y , width, height)\n\t    context.stroke()\n\t    context.restore()\n\t    }\n\t    context.fillStyle = style.fillStyle;\n\t    context.lineWidth =  style.lineWidth;\n\t    context.strokeStyle = style.strokeStyle;\n\t    context.lineJoin = 'miter';\n    }\n}\n\n//# sourceURL=webpack://craters/./src/Entity.js?");

/***/ }),

/***/ "./src/Fixture/Circle.js":
/*!*******************************!*\
  !*** ./src/Fixture/Circle.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Circle)\n/* harmony export */ });\n/* harmony import */ var _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Geometry/Geometry.js */ \"./src/Geometry/Geometry.js\");\n/* harmony import */ var _Geometry_AABB_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Geometry/AABB.js */ \"./src/Geometry/AABB.js\");\n// ## Circle\n// Represents a circular fixture\n\n\n\nclass Circle {\n\tconstructor(pos, r) {\n\t\tthis['type'] = 'circle'\n\t\tthis['pos'] = pos || new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__.Vector();\n\t\tthis['r'] = r || 0;\n\t\tthis['offset'] = new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__.Vector();\n\t}\n\t\n\t// Compute the axis-aligned bounding AABB (AABB) of this Circle.\n\t//\n\t// Note: Returns a _new_ `Polygon` each time you call this.\n\t/**\n\t* @return {Polygon} The AABB\n\t*/\n\tgetAABB() {\n\t\tvar r = this['r'];\n\t\tvar corner = this['pos'].clone().add(this['offset']).sub(new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__.Vector(r, r));\n\t\treturn new _Geometry_AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](corner, r*2, r*2).toPolygon();\n\t};\n\tgetCentroid() {\n\t\tlet aabb = this.getAABB();\n\t\tlet x = aabb.edges[3].x;\n\t\tlet y = aabb.edges[2].y;\n\t\tlet cx = (aabb.edges[0].x - x) / 2;\n\t\tlet cy = (aabb.edges[1].y - y) / 2;\n\t\treturn new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__.Vector(cx, cy);\n\t}\n\t// Set the current offset to apply to the radius.\n\t/**\n\t* @param {Vector} offset The new offset vector.\n\t* @return {Circle} This for chaining.\n\t*/\n\tsetOffset(offset) {\n\t\tthis['offset'] = offset;\n\t\treturn this;\n\t}\n}\n\n//# sourceURL=webpack://craters/./src/Fixture/Circle.js?");

/***/ }),

/***/ "./src/Fixture/Fixtures.js":
/*!*********************************!*\
  !*** ./src/Fixture/Fixtures.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Fixture_Circle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Fixture/Circle.js */ \"./src/Fixture/Circle.js\");\n/* harmony import */ var _Fixture_Polygon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Fixture/Polygon.js */ \"./src/Fixture/Polygon.js\");\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({Circle: _Fixture_Circle_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"], Polygon: _Fixture_Polygon_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]});\n\n//# sourceURL=webpack://craters/./src/Fixture/Fixtures.js?");

/***/ }),

/***/ "./src/Fixture/Polygon.js":
/*!********************************!*\
  !*** ./src/Fixture/Polygon.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Polygon)\n/* harmony export */ });\n/* harmony import */ var _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Geometry/Geometry.js */ \"./src/Geometry/Geometry.js\");\n/* harmony import */ var _Geometry_AABB_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Geometry/AABB.js */ \"./src/Geometry/AABB.js\");\n// ## Polygon\n// Represents a *convex* polygon with any number of points (specified in counter-clockwise order)\n\n\n\nclass Polygon {\n\tconstructor(pos, points) {\n\t\tthis['type'] = 'polygon'\n\t\tthis['pos'] = pos || new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__.Vector();\n\t\tthis['angle'] = 0;\n\t\tthis['offset'] = new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__.Vector();\n\t\tthis.setPoints(points || []);\n\t}\n\tsetPoints(points) {\n\t\t// Only re-allocate if this is a new polygon or the number of points has changed.\n\t\tvar lengthChanged = !this['points'] || this['points'].length !== points.length;\n\t\tif (lengthChanged) {\n\t\t\tvar i;\n\t\t\tvar calcPoints = this['calcPoints'] = [];\n\t\t\tvar edges = this['edges'] = [];\n\t\t\tvar normals = this['normals'] = [];\n\t\t\t// Allocate the vector arrays for the calculated properties\n\t\t\tfor (i = 0; i < points.length; i++) {\n\t\t\t// Remove consecutive duplicate points\n\t\t\tvar p1 = points[i];\n\t\t\tvar p2 = i < points.length - 1 ? points[i + 1] : points[0];\n\t\t\tif (p1 !== p2 && p1.x === p2.x && p1.y === p2.y) {\n\t\t\tpoints.splice(i, 1);\n\t\t\ti -= 1;\n\t\t\tcontinue;\n\t\t\t}\n\t\t\tcalcPoints.push(new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__.Vector());\n\t\t\tedges.push(new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__.Vector());\n\t\t\tnormals.push(new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__.Vector());\n\t\t\t}\n\t\t}\n\t\tthis['points'] = points;\n\t\tthis._recalc();\n\t\treturn this;\n\t};\n\tsetAngle(angle) {\n\t\tthis['angle'] = angle;\n\t\tthis._recalc();\n\t\treturn this;\n\t};\n\tsetOffset(offset) {\n\t\tthis['offset'] = offset;\n\t\tthis._recalc();\n\t\treturn this;\n\t};\n\t\n\trotate(angle) {\n\t\tvar points = this['points'];\n\t\tvar len = points.length;\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tpoints[i].rotate(angle);\n\t\t}\n\t\tthis._recalc();\n\t\treturn this;\n\t};\n\ttranslate(x, y) {\n\t\tvar points = this['points'];\n\t\tvar len = points.length;\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tpoints[i][\"x\"] += x;\n\t\t\tpoints[i][\"y\"] += y;\n\t\t}\n\t\tthis._recalc();\n\t\treturn this;\n\t};\n\t\n\t_recalc() {\n\t\tvar calcPoints = this['calcPoints'];\n\t\tvar edges = this['edges'];\n\t\tvar normals = this['normals'];\n\t\t// Copy the original points array and apply the offset/angle\n\t\tvar points = this['points'];\n\t\tvar offset = this['offset'];\n\t\tvar angle = this['angle'];\n\t\tvar len = points.length;\n\t\tvar i;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tvar calcPoint = calcPoints[i].copy(points[i]);\n\t\t\tcalcPoint[\"x\"] += offset[\"x\"];\n\t\t\tcalcPoint[\"y\"] += offset[\"y\"];\n\t\t\tif (angle !== 0) {\n\t\t\t\tcalcPoint.rotate(angle);\n\t\t\t}\n\t\t}\n\t\t// Calculate the edges/normals\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tvar p1 = calcPoints[i];\n\t\t\tvar p2 = i < len - 1 ? calcPoints[i + 1] : calcPoints[0];\n\t\t\tvar e = edges[i].copy(p2).sub(p1);\n\t\t\tnormals[i].copy(e).perp().normalize();\n\t\t}\n\t\treturn this;\n\t};\n\t\n\tgetAABB() {\n\t\tvar points = this[\"calcPoints\"];\n\t\tvar len = points.length;\n\t\tvar xMin = points[0][\"x\"];\n\t\tvar yMin = points[0][\"y\"];\n\t\tvar xMax = points[0][\"x\"];\n\t\tvar yMax = points[0][\"y\"];\n\t\tfor (var i = 1; i < len; i++) {\n\t\t\tvar point = points[i];\n\t\t\tif (point[\"x\"] < xMin) {\n\t\t\t\txMin = point[\"x\"];\n\t\t\t}\n\t\t\telse if (point[\"x\"] > xMax) {\n\t\t\t\txMax = point[\"x\"];\n\t\t\t}\n\t\t\tif (point[\"y\"] < yMin) {\n\t\t\t\tyMin = point[\"y\"];\n\t\t\t}\n\t\t\telse if (point[\"y\"] > yMax) {\n\t\t\t\tyMax = point[\"y\"];\n\t\t\t}\n\t\t}\n\t\treturn new _Geometry_AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this['pos'].clone().add(new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__.Vector(xMin, yMin)), xMax - xMin, yMax - yMin).toPolygon();\n\t};\n\t\n\tgetCentroid() {\n\t\tvar points = this[\"calcPoints\"];\n\t\tvar len = points.length;\n\t\tvar cx = 0;\n\t\tvar cy = 0;\n\t\tvar ar = 0;\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tvar p1 = points[i];\n\t\t\tvar p2 = i === len - 1 ? points[0] : points[i+1]; // Loop around if last point\n\t\t\tvar a = p1[\"x\"] * p2[\"y\"] - p2[\"x\"] * p1[\"y\"];\n\t\t\tcx += (p1[\"x\"] + p2[\"x\"]) * a;\n\t\t\tcy += (p1[\"y\"] + p2[\"y\"]) * a;\n\t\t\tar += a;\n\t\t}\n\t\tar = ar * 3; // we want 1 / 6 the area and we currently have 2*area\n\t\tcx = cx / ar;\n\t\tcy = cy / ar;\n\t\treturn new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__.Vector(cx, cy);\n\t}\n}\n\n//# sourceURL=webpack://craters/./src/Fixture/Polygon.js?");

/***/ }),

/***/ "./src/Game.js":
/*!*********************!*\
  !*** ./src/Game.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Game)\n/* harmony export */ });\n/* harmony import */ var _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Geometry/Geometry.js */ \"./src/Geometry/Geometry.js\");\n/* harmony import */ var _System_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./System.js */ \"./src/System.js\");\n/* harmony import */ var _Modules_Tilemap_Tilemap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Modules/Tilemap/Tilemap.js */ \"./src/Modules/Tilemap/Tilemap.js\");\n/* harmony import */ var _Collision_Broadphase_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Collision/Broadphase.js */ \"./src/Collision/Broadphase.js\");\n/* harmony import */ var _Collision_Narrowphase_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Collision/Narrowphase.js */ \"./src/Collision/Narrowphase.js\");\n/* harmony import */ var _Collision_Solver_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Collision/Solver.js */ \"./src/Collision/Solver.js\");\n/* harmony import */ var _Fixture_Circle_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Fixture/Circle.js */ \"./src/Fixture/Circle.js\");\n/* harmony import */ var _Fixture_Polygon_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Fixture/Polygon.js */ \"./src/Fixture/Polygon.js\");\n\n\n\n\n\n\n\n\n\n\n\nclass Game {\n\tconstructor(params) {\n\t\tparams.entities = params.entities || [];\n\t\tparams.size = params.size || new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__.Vector(1000, 500);\n\t\tparams.gravity = params.gravity || new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__.Vector();\n\t\tparams.quad = params.quad || new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__.Vector();\n\t\tparams.resources = params.resources || {\n\t\t\t// resources object\n\t\t};\n\t\tparams.resources.image = params.resources.image || [];\n\t\tparams.resources.audio = params.resources.audio || [];\n\t\tparams.resources.data = params.resources.data  || [];\n\t\t\n\t\tparams.fps = params.fps || 60;\n\t\tparams.debug = params.debug || false;\n\t\t\n\t\tthis.entities = params.entities;\n\t\tthis.debug = params.debug;\n\t\tthis.state = {\n\t\t\tsize: params.size,\n\t\t\tgravity: params.gravity\n\t\t}\n\t\n\t\t// create viewport\n\t\tthis.viewport = new _System_js__WEBPACK_IMPORTED_MODULE_1__.Canvas(this.state.size.x, this.state.size.y, params.container);\n\t\tthis.context = this.viewport.context;\n\t\t// Create new grid\n\t\tthis.quad = new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__.QuadTree({x: params.quad.x, y: params.quad.y, width: params.size.x, height: params.size.y});\n\t\tthis.solver = new _Collision_Solver_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]();\n\t\tthis.tilemap = new _Modules_Tilemap_Tilemap_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](params.tilemap, this.context, this.quad)\n\t\t\n\t\t// Loop main game\n\t\tthis.loop = new _System_js__WEBPACK_IMPORTED_MODULE_1__.Loop(this, params.fps)\n\t\twindow['cg'] = this;\n\t}\n\t\n\taddObject(object) {\n\t\t// used for adding entities\n\t\tobject.context = this.context;\n\t\treturn this.entities.push(object)\n\t}\n\t\n\tremoveObject(index) {\n\t\t// used to remove entities\n\t\t// this.quad.remove(this.entities[index])\n\t\treturn this.entities.splice(index, 1)\n\t}\n\t\n\tupdate() {\n\t\tthis.quad.clear()\n\t\tthis.tilemap.update()\n\t\t// Loop through all bodies and update one at a time\n\t\tthis.entities.forEach((body) => {\n\t\t\t// update grid quad\n\t\t\tlet item = body;\n\t\t\tlet bounds = item.fixture.getAABB();\n\t\t\tlet edges = bounds.edges;\n\t\t\tlet width = (edges[0].x - edges[2].x) / 2,\n\t\t\t\theight = (edges[1].y - edges[3].y) / 2;\n\t\t\tlet position = item.state.position;\n\t\t\tlet x = position.x,\n\t\t\t\ty = position.y;\n\t\t\tif(item.fixture.type == \"circle\")\n\t\t\tx = position.x - (width / 2),\n\t\t\ty = position.y - (height / 2);\n\t\t\tthis.quad.insert({x , y , width, height, item})\n\t\t\t\n\t\t\tlet broad = _Collision_Broadphase_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].query(body, this.quad)\n\t\t\tlet narrow = _Collision_Narrowphase_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].query(body, broad)\n\t\t\tthis.solver.resolve(body, narrow);\n\t\t\t// kinematics\n\t\t\tlet gravity = this.state.gravity.clone().scale(body.gravityFactor.x, body.gravityFactor.y);\n\t\t\tlet mass = body.state.mass;\n\t\t\t\n\t\t\tbody.state.acceleration.add(gravity);\n\t\t\tbody.state.velocity.add(body.state.acceleration);\n\t\t\t\n\t\t\tbody.state.velocity.x = Math.min(body.state.velocity.x, body.state.maxVelocity.x);\n\t\t\tbody.state.velocity.y = Math.min(body.state.velocity.y, body.state.maxVelocity.y);\n\t\t\t\n\t\t\tbody.state.position.add(body.state.velocity.clone().scale(1 / this.state.loop.nframe))\n\t\t\tbody.update();\n\t\t})\n\t}\n\t\n\trender() {\n\t\t// background clear\n\t\tthis.viewport.clear()\n\t\tthis.tilemap.render()\n\t\t\n\t\tif(this.debug) {\n\t\t\tlet node = this.quad.root;\n\t\t\tlet drawBound = (node) => {\n\t\t\t\tlet bounds = node._bounds;\n\t\t\t\tlet abs = _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__.Maths.abs;\n\t\t\t\tlet context = this.context;\n\t\t\t\t\n\t\t\t\tcontext.save()\n\t\t\t\tcontext.strokeStyle = \"green\";\n\t\t\t\tcontext.lineWidth = \"2\";\n\t\t\t\tcontext.beginPath();\n\t\t\t\tcontext.rect(bounds.x, bounds.y, bounds.width, bounds.height);\n\t\t\t\t\n\t\t\t\tlet children = node.getChildren();\n\t\t\t\tlet childlength = children.length;\n\t\t\t\tlet childNode;\n\t\t\t\tif(childlength) {\n\t\t\t\t\tfor(let j = 0; j < childlength; j++) {\n\t\t\t\t\tchildNode = children[j];\n\t\t\t\t\tcontext.beginPath();\n\t\t\t\t\tcontext.rect(childNode.x, childNode.y, childNode.width, childNode.height);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tlet len = node.nodes.length;\n\t\t\t\tfor(let i = 0; i < len; i++) {\n\t\t\t\t\tdrawBound(node.nodes[i]);\n\t\t\t\t}\n\t\t\t\tcontext.stroke()\n\t\t\t\tcontext.restore();\n\t\t\t}\n\t\t\t// draw the QuadTree grid\n\t\t\tdrawBound(node);\n\t\t}\n\t\t\n\t\tthis.entities.forEach((body) => {\n\t\t\t// render body\n\t\t\tbody.render();\n\t\t\tbody.texture.update();\n\t\t\tbody.texture.render();\n\t\t})\n\t}\n}\n\n//# sourceURL=webpack://craters/./src/Game.js?");

/***/ }),

/***/ "./src/Geometry/AABB.js":
/*!******************************!*\
  !*** ./src/Geometry/AABB.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AABB)\n/* harmony export */ });\n/* harmony import */ var _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Geometry/Geometry.js */ \"./src/Geometry/Geometry.js\");\n/* harmony import */ var _Fixture_Polygon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Fixture/Polygon.js */ \"./src/Fixture/Polygon.js\");\n// ## AABB\n// Represents an axis-aligned AABB, with a width and height.\n\n\n\nclass AABB {\n\tconstructor(pos, w, h) {\n\t\tthis['pos'] = pos || new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__.Vector();\n\t\tthis['w'] = w || 0;\n\t\tthis['h'] = h || 0;\n\t}\n\t\n\t// Returns a polygon whose edges are the same as this AABB.\n\ttoPolygon() {\n\t\tvar pos = this['pos'];\n\t\tvar w = this['w'];\n\t\tvar h = this['h'];\n\t\treturn new _Fixture_Polygon_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__.Vector(pos['x'], pos['y']), [\n\t\t\tnew _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__.Vector(), new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__.Vector(w, 0),\n\t\t\tnew _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__.Vector(w,h), new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_0__.Vector(0,h)\n\t\t]);\n\t}\n}\n\n//# sourceURL=webpack://craters/./src/Geometry/AABB.js?");

/***/ }),

/***/ "./src/Geometry/Common.js":
/*!********************************!*\
  !*** ./src/Geometry/Common.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst degToRad = function(angle) {\n    return angle * Math.PI / 180;\n};\n\nconst radToDeg = function(angle) {\n    return angle * 180 / Math.PI;\n};\n\nconst distance = function(x1, y1, x2, y2) {\n    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n};\n\nconst map = function(value, low1, high1, low2, high2) {\n    return low2 + (high2 - low2) * (value - low1) / (high1 - low1);\n};\n\nconst boundary = function(value, min, max) {\n    return Math.min(Math.max(value, min), max)\n};\n\nconst abs = function abs(x) {\n\treturn (x < 0 ? -x : x)\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({abs, boundary, degToRad, radToDeg, distance, map});\n\n//# sourceURL=webpack://craters/./src/Geometry/Common.js?");

/***/ }),

/***/ "./src/Geometry/Geometry.js":
/*!**********************************!*\
  !*** ./src/Geometry/Geometry.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Maths\": () => (/* reexport safe */ _Common_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   \"Vector\": () => (/* reexport safe */ _Vector_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   \"QuadTree\": () => (/* reexport safe */ _QuadTree_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _Common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Common.js */ \"./src/Geometry/Common.js\");\n/* harmony import */ var _QuadTree_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./QuadTree.js */ \"./src/Geometry/QuadTree.js\");\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Vector.js */ \"./src/Geometry/Vector.js\");\n// load the methods and sub divided them\n// to make bite sized methods\n// vectors, fixtures, common\n\n\n\n\n\n\n//# sourceURL=webpack://craters/./src/Geometry/Geometry.js?");

/***/ }),

/***/ "./src/Geometry/QuadTree.js":
/*!**********************************!*\
  !*** ./src/Geometry/QuadTree.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ QuadTree)\n/* harmony export */ });\n/*jslint vars: true, nomen: true, plusplus: true, continue:true, forin:true */\n/*global Node, BoundsNode */\n\n/*\n\tThe MIT License\n\n\tCopyright (c) 2011 Mike Chambers\n\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\n\tThe above copyright notice and this permission notice shall be included in\n\tall copies or substantial portions of the Software.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\tTHE SOFTWARE.\n*/\n\n\n/**\n* A QuadTree implementation in JavaScript, a 2d spatial subdivision algorithm.\n* @module QuadTree\n**/\n\n    /****************** QuadTree ****************/\n\n    /**\n    * QuadTree data structure.\n    * @class QuadTree\n    * @constructor\n    * @param {Object} An object representing the bounds of the top level of the QuadTree. The object \n    * should contain the following properties : x, y, width, height\n    * @param {Boolean} pointQuad Whether the QuadTree will contain points (true), or items with bounds \n    * (width / height)(false). Default value is false.\n    * @param {Number} maxDepth The maximum number of levels that the quadtree will create. Default is 4.\n    * @param {Number} maxChildren The maximum number of children that a node can contain before it is split into sub-nodes.\n    **/\n    function QuadTree(bounds, pointQuad, maxDepth, maxChildren) {\n        var node;\n        if (pointQuad) {\n\n            node = new Node(bounds, 0, maxDepth, maxChildren);\n        } else {\n            node = new BoundsNode(bounds, 0, maxDepth, maxChildren);\n        }\n\n        this.root = node;\n    }\n\n    /**\n    * The root node of the QuadTree which covers the entire area being segmented.\n    * @property root\n    * @type Node\n    **/\n    QuadTree.prototype.root = null;\n\n\n    /**\n    * Inserts an item into the QuadTree.\n    * @method insert\n    * @param {Object|Array} item The item or Array of items to be inserted into the QuadTree. The item should expose x, y \n    * properties that represents its position in 2D space.\n    **/\n    QuadTree.prototype.insert = function (item) {\n        if (item instanceof Array) {\n            var len = item.length;\n\n            var i;\n            for (i = 0; i < len; i++) {\n                this.root.insert(item[i]);\n            }\n        } else {\n            this.root.insert(item);\n        }\n    };\n\n    /**\n    * Clears all nodes and children from the QuadTree\n    * @method clear\n    **/\n    QuadTree.prototype.clear = function () {\n        this.root.clear();\n    };\n\n    /**\n    * Retrieves all items / points in the same node as the specified item / point. If the specified item\n    * overlaps the bounds of a node, then all children in both nodes will be returned.\n    * @method retrieve\n    * @param {Object} item An object representing a 2D coordinate point (with x, y properties), or a shape\n    * with dimensions (x, y, width, height) properties.\n    **/\n    QuadTree.prototype.retrieve = function (item) {\n        //get a copy of the array of items\n        var out = this.root.retrieve(item).slice(0);\n        return out;\n    };\n\n    /************** Node ********************/\n\n\n    function Node(bounds, depth, maxDepth, maxChildren) {\n        this._bounds = bounds;\n        this.children = [];\n        this.nodes = [];\n\n        if (maxChildren) {\n            this._maxChildren = maxChildren;\n        }\n\n        if (maxDepth) {\n            this._maxDepth = maxDepth;\n        }\n\n        if (depth) {\n            this._depth = depth;\n        }\n    }\n\n    //subnodes\n    Node.prototype.nodes = null;\n    Node.prototype._classConstructor = Node;\n\n    //children contained directly in the node\n    Node.prototype.children = null;\n    Node.prototype._bounds = null;\n\n    //read only\n    Node.prototype._depth = 0;\n\n    Node.prototype._maxChildren = 4;\n    Node.prototype._maxDepth = 4;\n\n    Node.TOP_LEFT = 0;\n    Node.TOP_RIGHT = 1;\n    Node.BOTTOM_LEFT = 2;\n    Node.BOTTOM_RIGHT = 3;\n\n\n    Node.prototype.insert = function (item) {\n        if (this.nodes.length) {\n            var index = this._findIndex(item);\n\n            this.nodes[index].insert(item);\n\n            return;\n        }\n\n        this.children.push(item);\n\n        var len = this.children.length;\n        if (!(this._depth >= this._maxDepth) &&\n                len > this._maxChildren) {\n            \n            this.subdivide();\n\n            var i;\n            for (i = 0; i < len; i++) {\n                this.insert(this.children[i]);\n            }\n\n            this.children.length = 0;\n        }\n    };\n\n    Node.prototype.retrieve = function (item) {\n        if (this.nodes.length) {\n            var index = this._findIndex(item);\n\n            return this.nodes[index].retrieve(item);\n        }\n\n        return this.children;\n    };\n\n    Node.prototype._findIndex = function (item) {\n        var b = this._bounds;\n        var left = (item.x > b.x + b.width / 2) ? false : true;\n        var top = (item.y > b.y + b.height / 2) ? false : true;\n\n        //top left\n        var index = Node.TOP_LEFT;\n        if (left) {\n            //left side\n            if (!top) {\n                //bottom left\n                index = Node.BOTTOM_LEFT;\n            }\n        } else {\n            //right side\n            if (top) {\n                //top right\n                index = Node.TOP_RIGHT;\n            } else {\n                //bottom right\n                index = Node.BOTTOM_RIGHT;\n            }\n        }\n\n        return index;\n    };\n\n\n    Node.prototype.subdivide = function () {\n        var depth = this._depth + 1;\n\n        var bx = this._bounds.x;\n        var by = this._bounds.y;\n\n        //floor the values\n        var b_w_h = (this._bounds.width / 2); //todo: Math.floor?\n        var b_h_h = (this._bounds.height / 2);\n        var bx_b_w_h = bx + b_w_h;\n        var by_b_h_h = by + b_h_h;\n\n        //top left\n        this.nodes[Node.TOP_LEFT] = new this._classConstructor({\n            x: bx,\n            y: by,\n            width: b_w_h,\n            height: b_h_h\n        },\n            depth, this._maxDepth, this._maxChildren);\n\n        //top right\n        this.nodes[Node.TOP_RIGHT] = new this._classConstructor({\n            x: bx_b_w_h,\n            y: by,\n            width: b_w_h,\n            height: b_h_h\n        },\n            depth, this._maxDepth, this._maxChildren);\n\n        //bottom left\n        this.nodes[Node.BOTTOM_LEFT] = new this._classConstructor({\n            x: bx,\n            y: by_b_h_h,\n            width: b_w_h,\n            height: b_h_h\n        },\n            depth, this._maxDepth, this._maxChildren);\n\n\n        //bottom right\n        this.nodes[Node.BOTTOM_RIGHT] = new this._classConstructor({\n            x: bx_b_w_h,\n            y: by_b_h_h,\n            width: b_w_h,\n            height: b_h_h\n        },\n            depth, this._maxDepth, this._maxChildren);\n    };\n\n    Node.prototype.clear = function () {\n        this.children.length = 0;\n\n        var len = this.nodes.length;\n        \n        var i;\n        for (i = 0; i < len; i++) {\n            this.nodes[i].clear();\n        }\n\n        this.nodes.length = 0;\n    };\n    \n\n    /******************** BoundsQuadTree ****************/\n\n    function BoundsNode(bounds, depth, maxChildren, maxDepth) {\n        Node.call(this, bounds, depth, maxChildren, maxDepth);\n        this._stuckChildren = [];\n    }\n\n    BoundsNode.prototype = new Node();\n    BoundsNode.prototype._classConstructor = BoundsNode;\n    BoundsNode.prototype._stuckChildren = null;\n\n    //we use this to collect and conctenate items being retrieved. This way\n    //we dont have to continuously create new Array instances.\n    //Note, when returned from QuadTree.retrieve, we then copy the array\n    BoundsNode.prototype._out = [];\n\n    BoundsNode.prototype.insert = function (item) {\n        if (this.nodes.length) {\n            var index = this._findIndex(item);\n            var node = this.nodes[index];\n\n            //todo: make _bounds bounds\n            if (item.x >= node._bounds.x &&\n                    item.x + item.width <= node._bounds.x + node._bounds.width &&\n                    item.y >= node._bounds.y &&\n                    item.y + item.height <= node._bounds.y + node._bounds.height) {\n                \n                this.nodes[index].insert(item);\n                \n            } else {\n                this._stuckChildren.push(item);\n            }\n\n            return;\n        }\n\n        this.children.push(item);\n\n        var len = this.children.length;\n\n        if (!(this._depth >= this._maxDepth) &&\n                len > this._maxChildren) {\n            \n            this.subdivide();\n\n            var i;\n            for (i = 0; i < len; i++) {\n                this.insert(this.children[i]);\n            }\n\n            this.children.length = 0;\n        }\n    };\n\n    BoundsNode.prototype.getChildren = function () {\n        return this.children.concat(this._stuckChildren);\n    };\n\n    BoundsNode.prototype.retrieve = function (item) {\n        var out = this._out;\n        out.length = 0;\n        if (this.nodes.length) {\n            var index = this._findIndex(item);\n            var node = this.nodes[index];\n\n            if (item.x >= node._bounds.x &&\n                    item.x + item.width <= node._bounds.x + node._bounds.width &&\n                    item.y >= node._bounds.y &&\n                    item.y + item.height <= node._bounds.y + node._bounds.height) {\n                \n                out.push.apply(out, this.nodes[index].retrieve(item));\n            } else {\n                //Part of the item are overlapping multiple child nodes. For each of the overlapping nodes, return all containing objects.\n\n                if (item.x <= this.nodes[Node.TOP_RIGHT]._bounds.x) {\n                    if (item.y <= this.nodes[Node.BOTTOM_LEFT]._bounds.y) {\n                        out.push.apply(out, this.nodes[Node.TOP_LEFT].getAllContent());\n                    }\n                    \n                    if (item.y + item.height > this.nodes[Node.BOTTOM_LEFT]._bounds.y) {\n                        out.push.apply(out, this.nodes[Node.BOTTOM_LEFT].getAllContent());\n                    }\n                }\n                \n                if (item.x + item.width > this.nodes[Node.TOP_RIGHT]._bounds.x) {//position+width bigger than middle x\n                    if (item.y <= this.nodes[Node.BOTTOM_RIGHT]._bounds.y) {\n                        out.push.apply(out, this.nodes[Node.TOP_RIGHT].getAllContent());\n                    }\n                    \n                    if (item.y + item.height > this.nodes[Node.BOTTOM_RIGHT]._bounds.y) {\n                        out.push.apply(out, this.nodes[Node.BOTTOM_RIGHT].getAllContent());\n                    }\n                }\n            }\n        }\n\n        out.push.apply(out, this._stuckChildren);\n        out.push.apply(out, this.children);\n\n        return out;\n    };\n\n    //Returns all contents of node.\n    BoundsNode.prototype.getAllContent = function () {\n        var out = this._out;\n        if (this.nodes.length) {\n            \n            var i;\n            for (i = 0; i < this.nodes.length; i++) {\n                this.nodes[i].getAllContent();\n            }\n        }\n        out.push.apply(out, this._stuckChildren);\n        out.push.apply(out, this.children);\n        return out;\n    };\n\n    BoundsNode.prototype.clear = function () {\n\n        this._stuckChildren.length = 0;\n\n        //array\n        this.children.length = 0;\n\n        var len = this.nodes.length;\n\n        if (!len) {\n            return;\n        }\n\n        var i;\n        for (i = 0; i < len; i++) {\n            this.nodes[i].clear();\n        }\n\n        //array\n        this.nodes.length = 0;\n\n        //we could call the super clear function but for now, im just going to inline it\n        //call the hidden super.clear, and make sure its called with this = this instance\n        //Object.getPrototypeOf(BoundsNode.prototype).clear.call(this);\n    };\n\n//# sourceURL=webpack://craters/./src/Geometry/QuadTree.js?");

/***/ }),

/***/ "./src/Geometry/SAT.js":
/*!*****************************!*\
  !*** ./src/Geometry/SAT.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector.js */ \"./src/Geometry/Vector.js\");\n/* harmony import */ var _AABB_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AABB.js */ \"./src/Geometry/AABB.js\");\n/* harmony import */ var _Fixture_Circle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Fixture/Circle.js */ \"./src/Fixture/Circle.js\");\n/* harmony import */ var _Fixture_Polygon_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Fixture/Polygon.js */ \"./src/Fixture/Polygon.js\");\n// Version 0.8.0 - Copyright 2012 - 2018 -  Jim Riecken <jimr@jimr.ca>\n//\n// Released under the MIT License - https://github.com/jriecken/sat-js\n//\n// A simple library for determining intersections of circles and\n// polygons using the Separating Axis Theorem.\n\n\n\n\n\n  var SAT = {AABB: _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"], Circle: _Fixture_Circle_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"], Polygon: _Fixture_Polygon_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]};\n  // ## Response\n  //\n  // An object representing the result of an intersection. Contains:\n  //  - The two objects participating in the intersection\n  //  - The vector representing the minimum change necessary to extract the first object\n  //    from the second one (as well as a unit vector in that direction and the magnitude\n  //    of the overlap)\n  //  - Whether the first object is entirely inside the second, and vice versa.\n  /**\n   * @constructor\n   */\n  function Response() {\n    this['a'] = null;\n    this['b'] = null;\n    this['overlapN'] = new _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    this['overlapV'] = new _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    this.clear();\n  }\n  SAT['Response'] = Response;\n\n  // Set some values of the response back to their defaults.  Call this between tests if\n  // you are going to reuse a single Response object for multiple intersection tests (recommented\n  // as it will avoid allcating extra memory)\n  /**\n   * @return {Response} This for chaining\n   */\n  Response.prototype['clear'] = Response.prototype.clear = function() {\n    this['aInB'] = true;\n    this['bInA'] = true;\n    this['overlap'] = Number.MAX_VALUE;\n    return this;\n  };\n\n  // ## Object Pools\n\n  // A pool of `Vector` objects that are used in calculations to avoid\n  // allocating memory.\n  /**\n   * @type {Array<Vector>}\n   */\n  var T_VECTORS = [];\n  for (var i = 0; i < 10; i++) { T_VECTORS.push(new _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]()); }\n\n  // A pool of arrays of numbers used in calculations to avoid allocating\n  // memory.\n  /**\n   * @type {Array<Array<number>>}\n   */\n  var T_ARRAYS = [];\n  for (var i = 0; i < 5; i++) { T_ARRAYS.push([]); }\n\n  // Temporary response used for polygon hit detection.\n  /**\n   * @type {Response}\n   */\n  var T_RESPONSE = new Response();\n\n  // Tiny \"point\" polygon used for polygon hit detection.\n  /**\n   * @type {Polygon}\n   */\n  var TEST_POINT = new _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](new _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](), 0.000001, 0.000001).toPolygon();\n\n  // ## Helper Functions\n\n  // Flattens the specified array of points onto a unit vector axis,\n  // resulting in a one dimensional range of the minimum and\n  // maximum value on that axis.\n  /**\n   * @param {Array<Vector>} points The points to flatten.\n   * @param {Vector} normal The unit vector axis to flatten on.\n   * @param {Array<number>} result An array.  After calling this function,\n   *   result[0] will be the minimum value,\n   *   result[1] will be the maximum value.\n   */\n  function flattenPointsOn(points, normal, result) {\n    var min = Number.MAX_VALUE;\n    var max = -Number.MAX_VALUE;\n    var len = points.length;\n    for (var i = 0; i < len; i++ ) {\n      // The magnitude of the projection of the point onto the normal\n      var dot = points[i].dot(normal);\n      if (dot < min) { min = dot; }\n      if (dot > max) { max = dot; }\n    }\n    result[0] = min; result[1] = max;\n  }\n\n  // Check whether two convex polygons are separated by the specified\n  // axis (must be a unit vector).\n  /**\n   * @param {Vector} aPos The position of the first polygon.\n   * @param {Vector} bPos The position of the second polygon.\n   * @param {Array<Vector>} aPoints The points in the first polygon.\n   * @param {Array<Vector>} bPoints The points in the second polygon.\n   * @param {Vector} axis The axis (unit sized) to test against.  The points of both polygons\n   *   will be projected onto this axis.\n   * @param {Response=} response A Response object (optional) which will be populated\n   *   if the axis is not a separating axis.\n   * @return {boolean} true if it is a separating axis, false otherwise.  If false,\n   *   and a response is passed in, information about how much overlap and\n   *   the direction of the overlap will be populated.\n   */\n  function isSeparatingAxis(aPos, bPos, aPoints, bPoints, axis, response) {\n    var rangeA = T_ARRAYS.pop();\n    var rangeB = T_ARRAYS.pop();\n    // The magnitude of the offset between the two polygons\n    var offsetV = T_VECTORS.pop().copy(bPos).sub(aPos);\n    var projectedOffset = offsetV.dot(axis);\n    // Project the polygons onto the axis.\n    flattenPointsOn(aPoints, axis, rangeA);\n    flattenPointsOn(bPoints, axis, rangeB);\n    // Move B's range to its position relative to A.\n    rangeB[0] += projectedOffset;\n    rangeB[1] += projectedOffset;\n    // Check if there is a gap. If there is, this is a separating axis and we can stop\n    if (rangeA[0] > rangeB[1] || rangeB[0] > rangeA[1]) {\n      T_VECTORS.push(offsetV);\n      T_ARRAYS.push(rangeA);\n      T_ARRAYS.push(rangeB);\n      return true;\n    }\n    // This is not a separating axis. If we're calculating a response, calculate the overlap.\n    if (response) {\n      var overlap = 0;\n      // A starts further left than B\n      if (rangeA[0] < rangeB[0]) {\n        response['aInB'] = false;\n        // A ends before B does. We have to pull A out of B\n        if (rangeA[1] < rangeB[1]) {\n          overlap = rangeA[1] - rangeB[0];\n          response['bInA'] = false;\n        // B is fully inside A.  Pick the shortest way out.\n        } else {\n          var option1 = rangeA[1] - rangeB[0];\n          var option2 = rangeB[1] - rangeA[0];\n          overlap = option1 < option2 ? option1 : -option2;\n        }\n      // B starts further left than A\n      } else {\n        response['bInA'] = false;\n        // B ends before A ends. We have to push A out of B\n        if (rangeA[1] > rangeB[1]) {\n          overlap = rangeA[0] - rangeB[1];\n          response['aInB'] = false;\n        // A is fully inside B.  Pick the shortest way out.\n        } else {\n          var option1 = rangeA[1] - rangeB[0];\n          var option2 = rangeB[1] - rangeA[0];\n          overlap = option1 < option2 ? option1 : -option2;\n        }\n      }\n      // If this is the smallest amount of overlap we've seen so far, set it as the minimum overlap.\n      var absOverlap = Math.abs(overlap);\n      if (absOverlap < response['overlap']) {\n        response['overlap'] = absOverlap;\n        response['overlapN'].copy(axis);\n        if (overlap < 0) {\n          response['overlapN'].reverse();\n        }\n      }\n    }\n    T_VECTORS.push(offsetV);\n    T_ARRAYS.push(rangeA);\n    T_ARRAYS.push(rangeB);\n    return false;\n  }\n  SAT['isSeparatingAxis'] = isSeparatingAxis;\n\n  // Calculates which Voronoi region a point is on a line segment.\n  // It is assumed that both the line and the point are relative to `(0,0)`\n  //\n  //            |       (0)      |\n  //     (-1)  [S]--------------[E]  (1)\n  //            |       (0)      |\n  /**\n   * @param {Vector} line The line segment.\n   * @param {Vector} point The point.\n   * @return  {number} LEFT_VORONOI_REGION (-1) if it is the left region,\n   *          MIDDLE_VORONOI_REGION (0) if it is the middle region,\n   *          RIGHT_VORONOI_REGION (1) if it is the right region.\n   */\n  function voronoiRegion(line, point) {\n    var len2 = line.len2();\n    var dp = point.dot(line);\n    // If the point is beyond the start of the line, it is in the\n    // left voronoi region.\n    if (dp < 0) { return LEFT_VORONOI_REGION; }\n    // If the point is beyond the end of the line, it is in the\n    // right voronoi region.\n    else if (dp > len2) { return RIGHT_VORONOI_REGION; }\n    // Otherwise, it's in the middle one.\n    else { return MIDDLE_VORONOI_REGION; }\n  }\n  // Constants for Voronoi regions\n  /**\n   * @const\n   */\n  var LEFT_VORONOI_REGION = -1;\n  /**\n   * @const\n   */\n  var MIDDLE_VORONOI_REGION = 0;\n  /**\n   * @const\n   */\n  var RIGHT_VORONOI_REGION = 1;\n\n  // ## Collision Tests\n\n  // Check if a point is inside a circle.\n  /**\n   * @param {Vector} p The point to test.\n   * @param {Circle} c The circle to test.\n   * @return {boolean} true if the point is inside the circle, false if it is not.\n   */\n  function pointInCircle(p, c) {\n    var differenceV = T_VECTORS.pop().copy(p).sub(c['pos']).sub(c['offset']);\n    var radiusSq = c['r'] * c['r'];\n    var distanceSq = differenceV.len2();\n    T_VECTORS.push(differenceV);\n    // If the distance between is smaller than the radius then the point is inside the circle.\n    return distanceSq <= radiusSq;\n  }\n  SAT['pointInCircle'] = pointInCircle;\n\n  // Check if a point is inside a convex polygon.\n  /**\n   * @param {Vector} p The point to test.\n   * @param {Polygon} poly The polygon to test.\n   * @return {boolean} true if the point is inside the polygon, false if it is not.\n   */\n  function pointInPolygon(p, poly) {\n    TEST_POINT['pos'].copy(p);\n    T_RESPONSE.clear();\n    var result = testPolygonPolygon(TEST_POINT, poly, T_RESPONSE);\n    if (result) {\n      result = T_RESPONSE['aInB'];\n    }\n    return result;\n  }\n  SAT['pointInPolygon'] = pointInPolygon;\n\n  // Check if two circles collide.\n  /**\n   * @param {Circle} a The first circle.\n   * @param {Circle} b The second circle.\n   * @param {Response=} response Response object (optional) that will be populated if\n   *   the circles intersect.\n   * @return {boolean} true if the circles intersect, false if they don't.\n   */\n  function testCircleCircle(a, b, response) {\n    // Check if the distance between the centers of the two\n    // circles is greater than their combined radius.\n    var differenceV = T_VECTORS.pop().copy(b['pos']).add(b['offset']).sub(a['pos']).sub(a['offset']);\n    var totalRadius = a['r'] + b['r'];\n    var totalRadiusSq = totalRadius * totalRadius;\n    var distanceSq = differenceV.len2();\n    // If the distance is bigger than the combined radius, they don't intersect.\n    if (distanceSq > totalRadiusSq) {\n      T_VECTORS.push(differenceV);\n      return false;\n    }\n    // They intersect.  If we're calculating a response, calculate the overlap.\n    if (response) {\n      var dist = Math.sqrt(distanceSq);\n      response['a'] = a;\n      response['b'] = b;\n      response['overlap'] = totalRadius - dist;\n      response['overlapN'].copy(differenceV.normalize());\n      response['overlapV'].copy(differenceV).scale(response['overlap']);\n      response['aInB']= a['r'] <= b['r'] && dist <= b['r'] - a['r'];\n      response['bInA'] = b['r'] <= a['r'] && dist <= a['r'] - b['r'];\n    }\n    T_VECTORS.push(differenceV);\n    return true;\n  }\n  SAT['testCircleCircle'] = testCircleCircle;\n\n  // Check if a polygon and a circle collide.\n  /**\n   * @param {Polygon} polygon The polygon.\n   * @param {Circle} circle The circle.\n   * @param {Response=} response Response object (optional) that will be populated if\n   *   they interset.\n   * @return {boolean} true if they intersect, false if they don't.\n   */\n  function testPolygonCircle(polygon, circle, response) {\n    // Get the position of the circle relative to the polygon.\n    var circlePos = T_VECTORS.pop().copy(circle['pos']).add(circle['offset']).sub(polygon['pos']);\n    var radius = circle['r'];\n    var radius2 = radius * radius;\n    var points = polygon['calcPoints'];\n    var len = points.length;\n    var edge = T_VECTORS.pop();\n    var point = T_VECTORS.pop();\n\n    // For each edge in the polygon:\n    for (var i = 0; i < len; i++) {\n      var next = i === len - 1 ? 0 : i + 1;\n      var prev = i === 0 ? len - 1 : i - 1;\n      var overlap = 0;\n      var overlapN = null;\n\n      // Get the edge.\n      edge.copy(polygon['edges'][i]);\n      // Calculate the center of the circle relative to the starting point of the edge.\n      point.copy(circlePos).sub(points[i]);\n\n      // If the distance between the center of the circle and the point\n      // is bigger than the radius, the polygon is definitely not fully in\n      // the circle.\n      if (response && point.len2() > radius2) {\n        response['aInB'] = false;\n      }\n\n      // Calculate which Voronoi region the center of the circle is in.\n      var region = voronoiRegion(edge, point);\n      // If it's the left region:\n      if (region === LEFT_VORONOI_REGION) {\n        // We need to make sure we're in the RIGHT_VORONOI_REGION of the previous edge.\n        edge.copy(polygon['edges'][prev]);\n        // Calculate the center of the circle relative the starting point of the previous edge\n        var point2 = T_VECTORS.pop().copy(circlePos).sub(points[prev]);\n        region = voronoiRegion(edge, point2);\n        if (region === RIGHT_VORONOI_REGION) {\n          // It's in the region we want.  Check if the circle intersects the point.\n          var dist = point.len();\n          if (dist > radius) {\n            // No intersection\n            T_VECTORS.push(circlePos);\n            T_VECTORS.push(edge);\n            T_VECTORS.push(point);\n            T_VECTORS.push(point2);\n            return false;\n          } else if (response) {\n            // It intersects, calculate the overlap.\n            response['bInA'] = false;\n            overlapN = point.normalize();\n            overlap = radius - dist;\n          }\n        }\n        T_VECTORS.push(point2);\n      // If it's the right region:\n      } else if (region === RIGHT_VORONOI_REGION) {\n        // We need to make sure we're in the left region on the next edge\n        edge.copy(polygon['edges'][next]);\n        // Calculate the center of the circle relative to the starting point of the next edge.\n        point.copy(circlePos).sub(points[next]);\n        region = voronoiRegion(edge, point);\n        if (region === LEFT_VORONOI_REGION) {\n          // It's in the region we want.  Check if the circle intersects the point.\n          var dist = point.len();\n          if (dist > radius) {\n            // No intersection\n            T_VECTORS.push(circlePos);\n            T_VECTORS.push(edge);\n            T_VECTORS.push(point);\n            return false;\n          } else if (response) {\n            // It intersects, calculate the overlap.\n            response['bInA'] = false;\n            overlapN = point.normalize();\n            overlap = radius - dist;\n          }\n        }\n      // Otherwise, it's the middle region:\n      } else {\n        // Need to check if the circle is intersecting the edge,\n        // Change the edge into its \"edge normal\".\n        var normal = edge.perp().normalize();\n        // Find the perpendicular distance between the center of the\n        // circle and the edge.\n        var dist = point.dot(normal);\n        var distAbs = Math.abs(dist);\n        // If the circle is on the outside of the edge, there is no intersection.\n        if (dist > 0 && distAbs > radius) {\n          // No intersection\n          T_VECTORS.push(circlePos);\n          T_VECTORS.push(normal);\n          T_VECTORS.push(point);\n          return false;\n        } else if (response) {\n          // It intersects, calculate the overlap.\n          overlapN = normal;\n          overlap = radius - dist;\n          // If the center of the circle is on the outside of the edge, or part of the\n          // circle is on the outside, the circle is not fully inside the polygon.\n          if (dist >= 0 || overlap < 2 * radius) {\n            response['bInA'] = false;\n          }\n        }\n      }\n\n      // If this is the smallest overlap we've seen, keep it.\n      // (overlapN may be null if the circle was in the wrong Voronoi region).\n      if (overlapN && response && Math.abs(overlap) < Math.abs(response['overlap'])) {\n        response['overlap'] = overlap;\n        response['overlapN'].copy(overlapN);\n      }\n    }\n\n    // Calculate the final overlap vector - based on the smallest overlap.\n    if (response) {\n      response['a'] = polygon;\n      response['b'] = circle;\n      response['overlapV'].copy(response['overlapN']).scale(response['overlap']);\n    }\n    T_VECTORS.push(circlePos);\n    T_VECTORS.push(edge);\n    T_VECTORS.push(point);\n    return true;\n  }\n  SAT['testPolygonCircle'] = testPolygonCircle;\n\n  // Check if a circle and a polygon collide.\n  //\n  // **NOTE:** This is slightly less efficient than polygonCircle as it just\n  // runs polygonCircle and reverses everything at the end.\n  /**\n   * @param {Circle} circle The circle.\n   * @param {Polygon} polygon The polygon.\n   * @param {Response=} response Response object (optional) that will be populated if\n   *   they interset.\n   * @return {boolean} true if they intersect, false if they don't.\n   */\n  function testCirclePolygon(circle, polygon, response) {\n    // Test the polygon against the circle.\n    var result = testPolygonCircle(polygon, circle, response);\n    if (result && response) {\n      // Swap A and B in the response.\n      var a = response['a'];\n      var aInB = response['aInB'];\n      response['overlapN'].reverse();\n      response['overlapV'].reverse();\n      response['a'] = response['b'];\n      response['b'] = a;\n      response['aInB'] = response['bInA'];\n      response['bInA'] = aInB;\n    }\n    return result;\n  }\n  SAT['testCirclePolygon'] = testCirclePolygon;\n\n  // Checks whether polygons collide.\n  /**\n   * @param {Polygon} a The first polygon.\n   * @param {Polygon} b The second polygon.\n   * @param {Response=} response Response object (optional) that will be populated if\n   *   they interset.\n   * @return {boolean} true if they intersect, false if they don't.\n   */\n  function testPolygonPolygon(a, b, response) {\n    var aPoints = a['calcPoints'];\n    var aLen = aPoints.length;\n    var bPoints = b['calcPoints'];\n    var bLen = bPoints.length;\n    // If any of the edge normals of A is a separating axis, no intersection.\n    for (var i = 0; i < aLen; i++) {\n      if (isSeparatingAxis(a['pos'], b['pos'], aPoints, bPoints, a['normals'][i], response)) {\n        return false;\n      }\n    }\n    // If any of the edge normals of B is a separating axis, no intersection.\n    for (var i = 0;i < bLen; i++) {\n      if (isSeparatingAxis(a['pos'], b['pos'], aPoints, bPoints, b['normals'][i], response)) {\n        return false;\n      }\n    }\n    // Since none of the edge normals of A or B are a separating axis, there is an intersection\n    // and we've already calculated the smallest overlap (in isSeparatingAxis).  Calculate the\n    // final overlap vector.\n    if (response) {\n      response['a'] = a;\n      response['b'] = b;\n      response['overlapV'].copy(response['overlapN']).scale(response['overlap']);\n    }\n    return true;\n  }\n  SAT['testPolygonPolygon'] = testPolygonPolygon;\n\n  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SAT);\n\n//# sourceURL=webpack://craters/./src/Geometry/SAT.js?");

/***/ }),

/***/ "./src/Geometry/Vector.js":
/*!********************************!*\
  !*** ./src/Geometry/Vector.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Vector)\n/* harmony export */ });\n\n// Vector\n// ----------\n// Represents a vector in two dimensions with `x` and `y` properties.\n\n\n// Create a new Vector, optionally passing in the `x` and `y` coordinates. If\n// a coordinate is not specified, it will be set to `0`\n/**\n* @param {?number=} x The x position.\n* @param {?number=} y The y position.\n* @constructor\n*/\nfunction Vector(x, y) {\n\tthis['x'] = x || 0;\n\tthis['y'] = y || 0;\n}\n\n// Copy the values of another Vector into this one.\n/**\n* @param {Vector} other The other Vector.\n* @return {Vector} This for chaining.\n*/\nVector.prototype['copy'] = Vector.prototype.copy = function(other) {\n\tthis['x'] = other['x'];\n\tthis['y'] = other['y'];\n\treturn this;\n};\n\n// Create a new vector with the same coordinates as this on.\n/**\n* @return {Vector} The new cloned vector\n*/\nVector.prototype['clone'] = Vector.prototype.clone = function() {\n\treturn new Vector(this['x'], this['y']);\n};\n\n// Change this vector to be perpendicular to what it was before. (Effectively\n// roatates it 90 degrees in a clockwise direction)\n/**\n* @return {Vector} This for chaining.\n*/\nVector.prototype['perp'] = Vector.prototype.perp = function() {\n\tvar x = this['x'];\n\tthis['x'] = this['y'];\n\tthis['y'] = -x;\n\treturn this;\n};\n\n// Rotate this vector (counter-clockwise) by the specified angle (in radians).\n/**\n* @param {number} angle The angle to rotate (in radians)\n* @return {Vector} This for chaining.\n*/\nVector.prototype['rotate'] = Vector.prototype.rotate = function (angle) {\n\tvar x = this['x'];\n\tvar y = this['y'];\n\tthis['x'] = x * Math.cos(angle) - y * Math.sin(angle);\n\tthis['y'] = x * Math.sin(angle) + y * Math.cos(angle);\n\treturn this;\n};\n\n// Reverse this vector.\n/**\n* @return {Vector} This for chaining.\n*/\nVector.prototype['reverse'] = Vector.prototype.reverse = function() {\n\tthis['x'] = -this['x'];\n\tthis['y'] = -this['y'];\n\treturn this;\n};\n\n\n// Normalize this vector.  (make it have length of `1`)\n/**\n* @return {Vector} This for chaining.\n*/\nVector.prototype['normalize'] = Vector.prototype.normalize = function() {\n\tvar d = this.len();\n\tif(d > 0) {\n\t\tthis['x'] = this['x'] / d;\n\t\tthis['y'] = this['y'] / d;\n\t}\n\treturn this;\n};\n\n// Add another vector to this one.\n/**\n* @param {Vector} other The other Vector.\n* @return {Vector} This for chaining.\n*/\nVector.prototype['add'] = Vector.prototype.add = function(other) {\n\tthis['x'] += other['x'];\n\tthis['y'] += other['y'];\n\treturn this;\n};\n\n// Subtract another vector from this one.\n/**\n* @param {Vector} other The other Vector.\n* @return {Vector} This for chaiing.\n*/\nVector.prototype['sub'] = Vector.prototype.sub = function(other) {\n\tthis['x'] -= other['x'];\n\tthis['y'] -= other['y'];\n\treturn this;\n};\n\n// Scale this vector. An independent scaling factor can be provided\n// for each axis, or a single scaling factor that will scale both `x` and `y`.\n/**\n* @param {number} x The scaling factor in the x direction.\n* @param {?number=} y The scaling factor in the y direction.  If this\n*   is not specified, the x scaling factor will be used.\n* @return {Vector} This for chaining.\n*/\nVector.prototype['scale'] = Vector.prototype.scale = function(x,y) {\n\tthis['x'] *= x;\n\tthis['y'] *= typeof y != 'undefined' ? y : x;\n\treturn this;\n};\n\n// Project this vector on to another vector.\n/**\n* @param {Vector} other The vector to project onto.\n* @return {Vector} This for chaining.\n*/\nVector.prototype['project'] = Vector.prototype.project = function(other) {\n\tvar amt = this.dot(other) / other.len2();\n\tthis['x'] = amt * other['x'];\n\tthis['y'] = amt * other['y'];\n\treturn this;\n};\n\n// Project this vector onto a vector of unit length. This is slightly more efficient\n// than `project` when dealing with unit vectors.\n/**\n* @param {Vector} other The unit vector to project onto.\n* @return {Vector} This for chaining.\n*/\nVector.prototype['projectN'] = Vector.prototype.projectN = function(other) {\n\tvar amt = this.dot(other);\n\tthis['x'] = amt * other['x'];\n\tthis['y'] = amt * other['y'];\n\treturn this;\n};\n\n// Reflect this vector on an arbitrary axis.\n/**\n* @param {Vector} axis The vector representing the axis.\n* @return {Vector} This for chaining.\n*/\nVector.prototype['reflect'] = Vector.prototype.reflect = function(axis) {\n\tvar x = this['x'];\n\tvar y = this['y'];\n\tthis.project(axis).scale(2);\n\tthis['x'] -= x;\n\tthis['y'] -= y;\n\treturn this;\n};\n\n// Reflect this vector on an arbitrary axis (represented by a unit vector). This is\n// slightly more efficient than `reflect` when dealing with an axis that is a unit vector.\n/**\n* @param {Vector} axis The unit vector representing the axis.\n* @return {Vector} This for chaining.\n*/\nVector.prototype['reflectN'] = Vector.prototype.reflectN = function(axis) {\n\tvar x = this['x'];\n\tvar y = this['y'];\n\tthis.projectN(axis).scale(2);\n\tthis['x'] -= x;\n\tthis['y'] -= y;\n\treturn this;\n};\n\n// Get the dot product of this vector and another.\n/**\n* @param {Vector}  other The vector to dot this one against.\n* @return {number} The dot product.\n*/\nVector.prototype['dot'] = Vector.prototype.dot = function(other) {\n\treturn this['x'] * other['x'] + this['y'] * other['y'];\n};\n\n// Get the squared length of this vector.\n/**\n* @return {number} The length^2 of this vector.\n*/\nVector.prototype['len2'] = Vector.prototype.len2 = function() {\n\treturn this.dot(this);\n};\n\n// Get the length of this vector.\n/**\n* @return {number} The length of this vector.\n*/\nVector.prototype['len'] = Vector.prototype.len = function() {\n\treturn Math.sqrt(this.len2());\n};\n\n//# sourceURL=webpack://craters/./src/Geometry/Vector.js?");

/***/ }),

/***/ "./src/Modules/Tilemap/Tile.js":
/*!*************************************!*\
  !*** ./src/Modules/Tilemap/Tile.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Tile)\n/* harmony export */ });\n/* harmony import */ var _Texture_Textures_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Texture/Textures.js */ \"./src/Texture/Textures.js\");\n/* harmony import */ var _Fixture_Fixtures_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Fixture/Fixtures.js */ \"./src/Fixture/Fixtures.js\");\n/* harmony import */ var _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Geometry/Geometry.js */ \"./src/Geometry/Geometry.js\");\n\n\n\n\nclass Tile {\n\tconstructor(context, params, args) {\n\t\tlet vec = _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_2__.Vector;\n\t\tlet num = Number;\n\t\tlet obj = Object;\n\t\tlet str = String;\n\t\tlet arr = Array;\n\t\t\n\t\tthis.state = {\n\t\t// properties\n\t\t}\n\t\tthis.collision = {\n\t\tcollides: true\n\t\t}\n\t\tthis.type = 'kinematic';\n\t\tthis.context = context;\n\t\tparams = params || new obj({\n\t\t// texture properties\n\t\t})\n\t\tparams.style = params.style || new obj({\n\t\t// texture style properties\n\t\t})\n\t\tparams.style.fillStyle = params.style.fillStyle || new str(\"#ddd\")\n\t\tparams.style.lineWidth = params.style.lineWidth || new num(2)\n\t\tparams.style.strokeStyle = params.style.strokeStyle || new str(\"#333\")\n\t\tparams.frames = [Math.floor(args[0])]\n\t\t// params.image = null;\n\t\t// [tileId, row, col, tileset]\n\t\tthis.state.position = new _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_2__.Vector(params.tilewidth * args[1], params.tileheight * args[2])\n\t\t// console.log(this.state)\n\t\t// Todo circles too\n\t\tthis.fixture = new _Fixture_Fixtures_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Polygon(this.state.position, [{x:0, y:0}, {x:0, y:params.tileheight}, {x:params.tilewidth, y:params.tileheight}, {x:params.tilewidth, y:0}]);\n\t\tthis.texture = new _Texture_Textures_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Sprite(this, params);\n\t}\n};\n\n//# sourceURL=webpack://craters/./src/Modules/Tilemap/Tile.js?");

/***/ }),

/***/ "./src/Modules/Tilemap/Tilemap.js":
/*!****************************************!*\
  !*** ./src/Modules/Tilemap/Tilemap.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Tilemap)\n/* harmony export */ });\n/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tile.js */ \"./src/Modules/Tilemap/Tile.js\");\n\n\n// tilemap add (tilesheet)\nclass Tilemap {\n\tconstructor(params, context, quad) {\n\t\tthis.tilemaps = [];\n\t\tthis.level = null;\n\t\tthis.quad = quad;\n\t\tthis.pool = [];\n\t\tthis.context = context;\n\t}\n\t\n\t__load(tilemap) {\n\t\tlet tilesets = [];\n\t\tthis.pool = [];\n\t\t// parser\n\t\ttilemap.tilesets.forEach((params) => {\n\t\t\t// make a tile\n\t\t\ttilesets.push(params)\n\t\t});\n\t\t// populate\n\t\ttilemap.layers.forEach((layer) => {\n\t\t\tlayer.data.forEach((tile) => {\n\t\t\t// make an instance of a tile\n\t\t\t// array [tileId, row, col, tileset]\n\t\t\tlet params = tilesets[tile[3]];\n\t\t\tlet img\t= new Image()\n\t\t\timg.src = params.image;\n\t\t\timg.onload = () => {\n\t\t\t\tparams.image = img;\n\t\t\t\t\tlet tiles = new _Tile_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.context, params, tile);\n\t\t\t\t\tthis.quad.insert(tiles)\n\t\t\t\t\tthis.pool.push(tiles)\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\t\n\tload(tilemap, name) {\n\t\tthis.tilemaps[name] = tilemap;\n\t}\n\t\n\tset(name) {\n\t\tif(!this.tilemaps[name]) return;\n\t\tthis.__load(this.tilemaps[name]);\n\t}\n\t\n\tupdate(params) {\n\t\tthis.pool.forEach((tile) => {\n\t\t\tlet item = tile;\n\t\t\tlet bounds = item.fixture.getAABB();\n\t\t\tlet edges = bounds.edges;\n\t\t\tlet width = (edges[0].x - edges[2].x) / 2,\n\t\t\t    height = (edges[1].y - edges[3].y) / 2;\n\t\t\tlet position = item.state.position;\n\t\t\tlet x = position.x,\n\t\t\t    y = position.y;\n\t\t\tif(item.fixture.type == \"circle\")\n\t\t\tx = position.x - (width / 2),\n\t\t\ty = position.y - (height / 2);\n\n\t\t\tthis.quad.insert({x , y , width, height, item})\n\t\t\titem.texture.update();\n\t\t})\n\t}\n\t\n\trender(params) {\n\t\tthis.pool.forEach((tile) => {\n\t\t\ttile.texture.render();\n\t\t})\n\t}\n};\n\n//# sourceURL=webpack://craters/./src/Modules/Tilemap/Tilemap.js?");

/***/ }),

/***/ "./src/Polyfill.js":
/*!*************************!*\
  !*** ./src/Polyfill.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("// for nodejs environment\n// the script creates an equivalent of \n// requestAnimationFrame function\n\nvar cg = new Object();\nif (typeof window === 'undefined' && __webpack_require__.g) {\n    __webpack_require__.g.window = {\n        performance: {\n            now: function(start) {\n                if (!start) return Date.now()\n                var end = Date.now(start)\n                return Math.round((end[0] * 1000) + (end[1] / 1000000))\n            }\n        },\n        requestAnimationFrame: function(f) {\n            setImmediate(() => f(this.performance.now()))\n        }\n    }\n}\n\n// assingn cg to window object\nwindow['cg'] = cg;\n\n//# sourceURL=webpack://craters/./src/Polyfill.js?");

/***/ }),

/***/ "./src/System.js":
/*!***********************!*\
  !*** ./src/System.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Loop\": () => (/* binding */ Loop),\n/* harmony export */   \"Canvas\": () => (/* binding */ Canvas)\n/* harmony export */ });\n// Game Loop Module\n// This module contains the game loop, which handles\n// updating the game state and re-rendering the canvas\n// (using the updated state) at the configured tframe.\nclass Loop {\n    constructor(scope, tframe) {\n        var loop = {\n            delta: (1000 / tframe),\n            elapsed: 0,\n            tframe: (1000 / tframe),\n            nframe: tframe,\n            before: window.performance.now()\n        }\n        // Initialize timer variables so we can calculate tframe\n        // Main game rendering loop\n        loop.main = function() {\n            loop.startLoop = window.requestAnimationFrame(loop.main)\n            loop.delta = Math.round(((1000 / (window.performance.now() - loop.before) * 100) / 100))\n\n            if (window.performance.now() < loop.before + loop.tframe) return\n            loop.before = window.performance.now()\n            // Request a new Animation Frame\n            // setting to `stopLoop` so animation can be stopped via\n            loop.stopLoop = () => {\n                window.cancelAnimationFrame(loop.startLoop)\n            }\n            // update scope\n            if(scope.state)\n            scope.state.loop = loop;\n\n            // Update the game state\n            scope.update(loop.elapsed, loop.delta)\n            // Render the next frame\n            scope.render(loop.elapsed, loop.delta)\n            loop.elapsed++\n        }\n\n        // Start off main loop\n        loop.main()\n        return loop\n    }\n}\n\nclass Canvas {\n    constructor(width, height, container) {\n        container = document.querySelector(container || 'body')\n        // Generate a canvas and store it as our viewport\n        var canvas = document.createElement('canvas')\n        var context = canvas.getContext('2d')\n        // Pass our canvas' context to our getPixelRatio method\n        var backingStores = ['webkitBackingStorePixelRatio', 'mozBackingStorePixelRatio', 'msBackingStorePixelRatio', 'oBackingStorePixelRatio', 'backingStorePixelRatio']\n        var deviceRatio = window.devicePixelRatio\n        // Iterate through our backing store props and determine the proper backing ratio.\n        var backingRatio = backingStores.reduce(function(prev, curr) {\n            return (Object.prototype.hasOwnProperty.call(context, curr) ? context[curr] : 1)\n        })\n        // Return the proper pixel ratio by dividing the device ratio by the backing ratio\n        var ratio = deviceRatio / backingRatio\n\n        // Set the canvas' width then downscale via CSS\n        canvas.width = Math.round(width * ratio)\n        canvas.height = Math.round(height * ratio)\n        canvas.style.width = width + 'px'\n        canvas.style.height = height + 'px'\n        // Scale the context so we get accurate pixel density\n        context.setTransform(ratio, 0, 0, ratio, 0, 0)\n        // Append viewport into our game within the dom\n        container.insertBefore(canvas, container.firstChild)\n        canvas.context = canvas.getContext('2d')\n\n        canvas.resize = (scope, size) => {\n            canvas.style.width = size.x + 'px'\n            canvas.style.height = size.y + 'px'\n            canvas.width = Math.round(size.x * ratio)\n            canvas.height = Math.round(size.y * ratio)\n            context.setTransform(ratio, 0, 0, ratio, 0, 0)\n\n            scope.state.size.x = size.x\n            scope.state.size.y = size.y\n        }\n\n        canvas.clear = (v, w, x, y, z) => {\n            v = v || null\n            w = w || 0\n            x = x || 0\n            y = y || canvas.width\n            z = z || canvas.height\n\n            if (v) { // clear with color if true\n                canvas.context.save();\n                canvas.context.fillStyle = v;\n                canvas.context.fillRect(w, x, y, z)\n                canvas.context.fill();\n                canvas.context.restore();\n            } else {\n                canvas.context.clearRect(w, x, y, z)\n            };\n        }\n\n        canvas.camera = (x, y) => {\n            canvas.context.setTransform(1, 0, 0, 1, 0, 0) // reset the transform matrix\n            canvas.context.translate(-x, -y)\n        }\n\n        return canvas // return the canvas\n    }\n}\n\n//# sourceURL=webpack://craters/./src/System.js?");

/***/ }),

/***/ "./src/Texture/Sprite.js":
/*!*******************************!*\
  !*** ./src/Texture/Sprite.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Sprite)\n/* harmony export */ });\nclass Sprite {\n\tconstructor(object, params) {\n\t\tthis.size = {\n\t\t\tx: params.tilewidth,\n\t\t\ty: params.tileheight\n\t\t}\n\t\t\n\t\tthis.frame;\n\t\tthis.grid = [];\n\t\tthis.image = params.image;\n\t\tthis.object = object;\n\t\tthis.style = params.style;\n\t\tthis.fixture = object.fixture;\n\t\tthis.position = object.state.position;\n\t\tparams.frames = params.frames || [0];\n\t\t\n\t\tif(this.image instanceof Image) {\n\t\t\t\n\t\t\tfor(let h = 0; h < this.image.height; h += this.size.y){\n\t\t\tfor(let w = 0; w < this.image.width; w += this.size.x){\n\t\t\t\tthis.grid.push({x: w, y: h})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.animation = {frames: params.frames}\n\t}\n\t\n\tupdate() {\n\t\tthis.frame = this.animation.frames.shift()\n\t\tthis.animation.frames.push(this.frame)\n\t}\n\t\n\trender() {\n\tlet object = this.object;\n\tlet image = this.image;\n\tlet context = object.context;\n\tcontext.fillStyle = this.style.fillStyle;\n\tcontext.lineWidth = this.style.lineWidth;\n\tcontext.strokeStyle = this.style.strokeStyle;\n\tcontext.lineJoin = 'miter';\n\t\n\tswitch (object.fixture.type) {\n\t\t    case 'circle': {\n\t\t\t\tcontext.save();\n\t\t\t\tcontext.beginPath();\n\t\t\t\tcontext.ellipse(\n\t\t\t        object.state.position.x,\n\t\t\t        object.state.position.y,\n\t\t\t        object.fixture.r,\n\t\t\t        object.fixture.r,\n\t\t\t        0, 0,\n\t\t\t        Math.PI * 2\n\t\t        );\n\t\t        context.clip();\n\t\t        let frame = this.frame;\n\t\t        if(image instanceof Image) {\n\t\t        context.drawImage(this.image,\n\t\t\t        this.grid[frame].x, this.grid[frame].y, this.size.x, this.size.y,\n\t\t\t        object.state.position.x - object.fixture.r, object.state.position.y - object.fixture.r, this.size.x, this.size.y\n\t\t        )}\n\t\t        else {\n\t\t\t        context.fill();\n\t\t\t        context.stroke();\n\t\t        }\n\t\t        context.closePath();\n\t\t        context.restore();\n\t\t        break;\n\t\t    }\n\t\t    case 'polygon': {\n\t\t\t    context.save();\n\t\t        context.beginPath();\n\t\t        context.moveTo(object.state.position.x + object.fixture.points[0].x, object.state.position.y + object.fixture.points[0].y);\n\t\t        for (let i = 1; i < object.fixture.points.length; i++) {\n\t\t\t        let v = object.fixture.points[i];\n\t\t\t        context.lineTo(object.state.position.x + v.x, object.state.position.y + v.y);\n\t\t        };\n\t\t        context.lineTo(object.state.position.x + object.fixture.points[0].x, object.state.position.y + object.fixture.points[0].y);\n\t\t        context.clip();\n\t\t        let frame = this.frame;\n\t\t        if(image instanceof Image) {\n\t\t\t        context.drawImage(this.image,\n\t\t\t        this.grid[frame].x, this.grid[frame].y, this.size.x, this.size.y,\n\t\t\t        object.state.position.x, object.state.position.y, this.size.x, this.size.y\n\t\t        )}\n\t\t        else {\n\t\t\t        context.fill();\n\t\t\t        context.stroke();\n\t\t        }\n\t\t        context.closePath();\n\t\t        context.restore();\n\t\t        break;\n\t\t    }\n\t\t}\n\t}\n}\n\n//# sourceURL=webpack://craters/./src/Texture/Sprite.js?");

/***/ }),

/***/ "./src/Texture/Textures.js":
/*!*********************************!*\
  !*** ./src/Texture/Textures.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Sprite_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sprite.js */ \"./src/Texture/Sprite.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({Sprite: _Sprite_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]});\n\n//# sourceURL=webpack://craters/./src/Texture/Textures.js?");

/***/ }),

/***/ "./src/craters.js":
/*!************************!*\
  !*** ./src/craters.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Craters\": () => (/* binding */ Craters),\n/* harmony export */   \"Game\": () => (/* reexport safe */ _Game_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   \"Entity\": () => (/* reexport safe */ _Entity_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   \"Fixtures\": () => (/* reexport safe */ _Fixture_Fixtures_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   \"Vector\": () => (/* reexport safe */ _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_3__.Vector),\n/* harmony export */   \"Maths\": () => (/* reexport safe */ _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_3__.Maths)\n/* harmony export */ });\n/* harmony import */ var _Polyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Polyfill.js */ \"./src/Polyfill.js\");\n/* harmony import */ var _Polyfill_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Polyfill_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Entity_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Entity.js */ \"./src/Entity.js\");\n/* harmony import */ var _Game_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Game.js */ \"./src/Game.js\");\n/* harmony import */ var _Geometry_Geometry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Geometry/Geometry.js */ \"./src/Geometry/Geometry.js\");\n/* harmony import */ var _Fixture_Fixtures_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Fixture/Fixtures.js */ \"./src/Fixture/Fixtures.js\");\n// Craters.js micro game framework\n// This module contains the core craters framework fundamentals\n// it loads modules and exports them\n\n\n\n\n\n\n\n\nclass Craters {\n    static version() {\n        return '1.3.0'\n    }\n}\n\n\n\n//# sourceURL=webpack://craters/./src/craters.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/craters.js");
/******/ 	
/******/ })()
;